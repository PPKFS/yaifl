<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yaifl Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/mdbook-admonish.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="foundations/tech.html">The Tech</a></li><li class="chapter-item expanded affix "><a href="foundations/structure.html">Structure of the book</a></li><li class="chapter-item expanded affix "><a href="foundations/cabal.html">Cabal, Extensions, Dependencies</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">The Yaifl Library</li><li class="chapter-item expanded "><a href="foundations/effects.html"><strong aria-hidden="true">1.</strong> Effects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="effects/say.html"><strong aria-hidden="true">1.1.</strong> Saying</a></li><li class="chapter-item expanded "><a href="effects/logging.html"><strong aria-hidden="true">1.2.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="worldmodel.html"><strong aria-hidden="true">2.</strong> The World Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="worldmodel/typefamilies.html"><strong aria-hidden="true">2.1.</strong> WorldModel and WMx Type Families</a></li><li class="chapter-item expanded "><a href="worldmodel/objects.html"><strong aria-hidden="true">2.2.</strong> Objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="worldmodel/objects/entities-stores.html"><strong aria-hidden="true">2.2.1.</strong> Entities and Stores</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/objects.html"><strong aria-hidden="true">2.2.2.</strong> Objects, At Last</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/query.html"><strong aria-hidden="true">2.2.3.</strong> Object Querying Effect</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/data.html"><strong aria-hidden="true">2.2.4.</strong> ThingData and RoomData</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/specifics.html"><strong aria-hidden="true">2.2.5.</strong> Object Specifics</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/dynamic.html"><strong aria-hidden="true">2.2.6.</strong> Dynamic Objects</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/creation.html"><strong aria-hidden="true">2.2.7.</strong> Creating Objects</a></li><li class="chapter-item expanded "><a href="worldmodel/objects/move.html"><strong aria-hidden="true">2.2.8.</strong> Moving Objects</a></li></ol></li><li class="chapter-item expanded "><a href="worldmodel/rooms.html"><strong aria-hidden="true">2.3.</strong> Rooms and Spatial Stuff</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="worldmodel/directions.html"><strong aria-hidden="true">2.3.1.</strong> Directions</a></li><li class="chapter-item expanded "><a href="worldmodel/connections.html"><strong aria-hidden="true">2.3.2.</strong> Making Connections</a></li></ol></li><li class="chapter-item expanded "><a href="properties.html"><strong aria-hidden="true">2.4.</strong> Properties</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="properties/getsetmodify.html"><strong aria-hidden="true">2.4.1.</strong> Get, Set, Modify with TemplateHaskell</a></li><li class="chapter-item expanded "><a href="properties/standard.html"><strong aria-hidden="true">2.4.2.</strong> Standard Properties</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="properties/std/enclosing.html"><strong aria-hidden="true">2.4.2.1.</strong> Enclosing</a></li><li class="chapter-item expanded "><a href="properties/std/openable.html"><strong aria-hidden="true">2.4.2.2.</strong> Openable</a></li><li class="chapter-item expanded "><a href="properties/std/container.html"><strong aria-hidden="true">2.4.2.3.</strong> Container</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rulebooks.html"><strong aria-hidden="true">3.</strong> Rulebooks, Actions, and Activities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rulebooks/running.html"><strong aria-hidden="true">3.1.</strong> Running a Rulebook</a></li><li class="chapter-item expanded "><a href="rulebooks/ap.html"><strong aria-hidden="true">3.2.</strong> Action Processing</a></li><li class="chapter-item expanded "><a href="rulebooks/activities.html"><strong aria-hidden="true">3.3.</strong> Activities</a></li></ol></li><li class="chapter-item expanded "><a href="construction.html"><strong aria-hidden="true">4.</strong> Construction and Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="worldmodel/state.html"><strong aria-hidden="true">4.1.</strong> The World State</a></li></ol></li><li class="chapter-item expanded "><a href="test-framework.html"><strong aria-hidden="true">5.</strong> Testing Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tests/coverage.html"><strong aria-hidden="true">5.1.</strong> Test Coverage</a></li></ol></li><li class="chapter-item expanded "><a href="other_miscellania.html"><strong aria-hidden="true">6.</strong> Miscellenia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="misc/common.html"><strong aria-hidden="true">6.1.</strong> Module Files</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Properties</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Actions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Activities</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="other_miscellania.html">Module Headers and Other Miscellania</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yaifl Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="yaifl---yet-another-interactive-fiction-library"><a class="header" href="#yaifl---yet-another-interactive-fiction-library">Yaifl - <strong>Y</strong>et <strong>A</strong>nother <strong>I</strong>nteractive <strong>F</strong>iction <strong>L</strong>ibrary</a></h1>
<p>Yaifl is a library for writing interactive fiction (&quot;text adventures&quot;) in Haskell. It is heavily based off <a href="http://inform7.com/">Inform7</a> in terms of the semantic structure (things and rooms, rulebooks, the tests). I doubt anyone will ever choose this over Inform7 -- or Twine, TADS, etc. -- to actually produce a work of IF; so in this regard, this is more of a fiddle-toy than intended to be a platform for making games.</p>
<p>The internals of Inform are not the easiest to pick apart. Even with the wonderful literate programming style (which was the inspiration for me to write this 'book'), it's a tangled web of interlocking pieces that aren't easy to find something in. A large amount of the documentation is specifically about trying to strong-arm literate English into something a computer can understand. Plus, I want to avoid a handful of Inform's restrictions at a fundamental level (e.g. objects are considered entirely unique). </p>
<p>To this extent, <code>Yaifl</code> is less of a library for <em>writing</em> pieces of interactive fiction and more for fiddling about with <em>text adventure world models</em>. A lot of weird things are done due to the limitations of the language itself and its targets (i.e. the Z-Machine, or Glulx). For example, did you know that the action <strong>to look</strong> makes a table of <strong>every item in the entire game</strong>?</p>
<h2 id="why-this-book"><a class="header" href="#why-this-book">Why this book?</a></h2>
<p>I found I was trying to be a good samaritan and document my code, but given that the library works more in vague ideas
than function signatures, Haddock comments weren't ideal. Plus the structure of how the code needs to be to compile with
all its module dependencies is different to how I want to read my own documentation, and <em>also</em> different to how I want to
present my work if anyone finds it interesting. </p>
<p>As an aside, I also I wanted to try this whole &quot;literate programming&quot; thing. The main reason I hadn't looked into it more before
was the large brick wall of getting a build system up as well as dealing with separating literate source from compilable/editable source.
I doubt anyone will read this book except me, but I saw <a href="https://entangled.github.io">Entangled</a> presented at a talk and it seemed a cool idea I wanted to try.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tech"><a class="header" href="#the-tech">The Tech</a></h1>
<p>This is a brief overview of some of the pieces that I've used to make this project.</p>
<h2 id="the-model"><a class="header" href="#the-model">The Model</a></h2>
<p>Pretty much a clone of <code>Inform7</code> semantically, but with less flexibility at runtime -- the world model structure is fully defined at compile time, so adding new objects is easy during play but adding new kinds is not -- in exchange for nicer handling of the world model as a collection of possibly uninteresting objects (rather than a small, but very explicit set of 'interesting' ones).</p>
<h2 id="haskell"><a class="header" href="#haskell">Haskell</a></h2>
<p>Mostly it's <code>optics</code> (as my lens package of choice), <code>cleff</code> (as my effects/mtl replacement package of choice) and <code>sandwich</code> (as my test framework of choice).</p>
<h2 id="literate-programming"><a class="header" href="#literate-programming">Literate Programming</a></h2>
<p><code>entangled</code></p>
<h2 id="the-book"><a class="header" href="#the-book">The Book</a></h2>
<p><code>mdBook</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structure-of-the-book"><a class="header" href="#structure-of-the-book">Structure of the book</a></h1>
<p>It's not quite one module per page, but it's close. The aim is to start with the foundations of the library (basic types and building blocks) and then develops the object model followed by the properties (things that make it interesting) and then actions and rulebooks (making the simulation do things). Finally, there is an overview of all the tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cabal-extensions-dependencies"><a class="header" href="#cabal-extensions-dependencies">Cabal, Extensions, Dependencies</a></h1>
<p>This is probably a pretty dull page, so if you only care about the interesting stuff
you can skip it. But I wanted to do this literate programming thing properly, and also
it ensures I know what's going on in my <code>.cabal</code> files.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>Everything here is fairly standard project information.</p>
<pre><code class="language-cabal file=yaifl.cabal header=&quot;1&quot;">cabal-version:   3.0
name:            yaifl
version:         0.0.0.1
synopsis:        Yet another interactive fiction library.
description:     Yet another interactive fiction library.
homepage:        https://github.com/PPKFS/yaifl
bug-reports:     https://github.com/PPKFS/yaifl/issues
license:         MIT
author:          Avery
maintainer:      Avery &lt;thecommunistduck@hotmail.co.uk&gt;
copyright:       2022 Avery
category:        Game Development
build-type:      Simple
tested-with: GHC == 9.0.2

source-repository head
  type:     git
  location: https://github.com/PPKFS/yaifl.git
</code></pre>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>This is a pretty standard dependency list.</p>
<pre><code class="language-cabal file=yaifl.cabal">common common-options
  build-depends:
      base
    , containers
    , template-haskell
    , text
    , text-display
    , solitude
    , cleff
    , cleff-plugin
    , time
</code></pre>
<p>I still have no idea why the first 4 of these aren't in <code>base</code>. <code>solitude</code> is my personal prelude, which is
mostly re-exports of the excellent <a href="https://hackage.haskell.org/package/relude">relude</a> alternative prelude and
also some <code>optics</code>-lens things. </p>
<div id="admonition-why-optics-over-lens" class="admonition question">
<div class="admonition-title">
<a class="admonition-anchor-link" href="foundations/cabal.html#admonition-why-optics-over-lens">
<p>Why optics over lens?</p>
</a>
</div>
<div>
<ul>
<li>No idea, I just wanted to.</li>
<li>The error messages and the explicit <code>AffineTraversal</code> you get from combining a <code>Lens</code> and a <code>Prism</code> are cool though.</li>
</ul>
</div>
</div>
<pre><code class="language-cabal file=yaifl.cabal">    , display
    , prettyprinter
    , prettyprinter-ansi-terminal
</code></pre>
<p><code>display</code> is for being <em>technically</em> lawful with <code>Show</code> instances when it comes to logging and for making pretty error messages. I would also like to re-add <code>chapelure</code> but I've not quite found the use-case (maybe in the test suite). <code>prettyprinter</code> gives nicer string formatting options.</p>
<pre><code class="language-cabal file=yaifl.cabal">    , aeson
    , katip
    , enummapset
    , haskell-src-meta
    , haskell-src-exts
</code></pre>
<ul>
<li>
<p><code>enummapset</code> is a nice set of wrappers for using <code>Enum</code> keys in <code>IntMap</code>s for better performance (i.e. <code>Entity</code>).</p>
</li>
<li>
<p><code>haskell-src-*</code> I use because writing well-formed TH is hard, and I wanted to just write Haskell strings with
text substitutions in. </p>
</li>
<li>
<p><code>katip</code> is only currently used because it has excellent time formatting, but it's a bit heavy for that purpose.</p>
</li>
</ul>
<h2 id="ghc-extensions"><a class="header" href="#ghc-extensions">GHC extensions</a></h2>
<pre><code class="language-cabal file=yaifl.cabal">  ghc-options:
    -Wall -Wcompat -Widentities -Wredundant-constraints 
    -fhide-source-paths -Wno-unused-top-binds
    -Wmissing-deriving-strategies -O2 -flate-specialise
    -fspecialise-aggressively -fprint-potential-instances
    -fno-warn-unused-do-bind -haddock -fwrite-ide-info
    -fplugin=Cleff.Plugin
  default-language:   Haskell2010
  default-extensions:
    NoImplicitPrelude
    BlockArguments
    DataKinds
    DerivingStrategies
    FunctionalDependencies
    LambdaCase
    MultiWayIf
    OverloadedStrings
    TypeFamilies
    TypeApplications
    ConstraintKinds
    FlexibleInstances
    FlexibleContexts
    GeneralisedNewtypeDeriving
    DeriveGeneric
    DeriveTraversable
    StandaloneDeriving
    RankNTypes
    ScopedTypeVariables
    BangPatterns
    GADTs
    TypeOperators
    DerivingVia
</code></pre>
<p>We enable a whole bunch of options and extensions. Notably <code>NoImplicitPrelude</code> makes it easier than fiddling with
mixins for using <code>solitude</code> over <code>Prelude</code>, <code>BlockArguments</code> for my love of using inline <code>do</code> blocks, and <code>TypeFamilies</code>
because I like to try and be smarter than I am.</p>
<h2 id="library-stanza"><a class="header" href="#library-stanza">Library stanza</a></h2>
<pre><code class="language-cabal file=yaifl.cabal">library
  import:          common-options
  hs-source-dirs:  src
  exposed-modules:
    Yaifl

    --Yaifl.Actions.Action
    --Yaifl.Actions.Going
    --Yaifl.Actions.Looking

    --Yaifl.Activities.Activity
    --Yaifl.Activities.ChoosingNotableLocaleObjects
    --Yaifl.Activities.DescribingLocale
    --Yaifl.Activities.PrintingADarkRoom
    --Yaifl.Activities.PrintingDescriptionOfADarkRoom
    --Yaifl.Activities.PrintingLocaleParagraphAbout
    --Yaifl.Activities.PrintingNameOfSomething

    --Yaifl.ActivityCollection
    Yaifl.Common
    Yaifl.Directions
    Yaifl.Logger

    Yaifl.Objects.Create
    Yaifl.Objects.Dynamic
    Yaifl.Objects.Move
    Yaifl.Objects.Object
    Yaifl.Objects.ObjectData
    Yaifl.Objects.Query
    Yaifl.Objects.Room
    Yaifl.Objects.Specifics

    Yaifl.Properties.Container
    Yaifl.Properties.Enclosing
    Yaifl.Properties.Openable
    Yaifl.Properties.Property
    Yaifl.Properties.Query
    --Yaifl.Properties.Supporter
    Yaifl.Properties.TH

    --Yaifl.Rulebooks.ActionProcessing
    --Yaifl.Rulebooks.Args
    --Yaifl.Rulebooks.Rulebook
    --Yaifl.Rulebooks.WhenPlayBegins

    Yaifl.Say
    Yaifl.World
</code></pre>
<h2 id="test-stanza"><a class="header" href="#test-stanza">Test stanza</a></h2>
<ul>
<li><code>neat-interpolation</code> makes wrapped raw string quasi-quotes better, which is important given
how many room descriptions are very long lines of text. </li>
<li><code>sandwich</code> is a really sweet looking testing library so I wanted to try it.</li>
<li><code>conduit</code> I needed because of <code>MonadThrow</code> constraints for <code>sandwich</code>'s <code>shouldBe</code>.</li>
</ul>
<pre><code class="language-cabal file=yaifl.cabal">test-suite yaifl-test
  import:             common-options
  type:               exitcode-stdio-1.0
  hs-source-dirs:     test
  main-is:            Spec.hs
  build-depends:
    , sandwich
    , conduit
    , yaifl
  ghc-options:        -threaded -rtsopts -with-rtsopts=-N
  default-extensions:
    QuasiQuotes
    TemplateHaskell

  other-modules:
    Yaifl.Test.Chapter3.Bic
    Yaifl.Test.Chapter3.Common
    --Yaifl.Test.Chapter3.Verbosity
    Yaifl.Test.Common
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects"><a class="header" href="#effects">Effects</a></h1>
<p>Extensible (or algebraic) effects are cool, but I don't want to get into depth here and equally I cannot because I am too dumb. The jist of them is instead of a fixed ordering of monads which you can add <code>MonadFoo</code> constraints to ala <code>mtl</code>:</p>
<pre><code class="language-haskell">f :: (MonadIO m, MonadBar m) =&gt; m a
</code></pre>
<p>You instead write GADTs with some type wizardry to achieve the same thing as typeclasses. The major advantage is that you can interpret these in multiple different ways (consider a logging effect that can be chosen to be viewed as an IO computation, or a pure ignore effect) and you don't need to deal with the O(n^2) instance problem:</p>
<pre><code class="language-haskell">
data Bar m a where
  Log :: String -&gt; Bar m ()
  SomethingElse :: Bool -&gt; Int -&gt; Bar m a

runBarAsIO :: ...

runBarAsPure :: ...
</code></pre>
<h2 id="why-effects-and-not-mtl"><a class="header" href="#why-effects-and-not-mtl">Why effects and not mtl?</a></h2>
<p>The main reason is because effect frameworks are cool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaiflsay"><a class="header" href="#yaiflsay">Yaifl.Say</a></h1>
<p>This is just a riff on every <code>Teletype</code> example that seems to be standard with effect frameworks. It's slightly more involved than the logging effect because we have conditional saying as well as formatting to keep track of.</p>
<pre><code class="language-haskell file=src/Yaifl/Say.hs">{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Say
  ( -- * Types
    MessageBuffer (..)
  -- * Smart constructors
  , blankMessageBuffer
  -- * Buffer modification
  , setStyle
  , say
  , sayLn
  , sayIf

  , msgBufBuffer
  )
where

import Cleff.State ( State, get, modify )
import qualified Prettyprinter as PP
import qualified Prettyprinter.Render.Terminal as PPTTY
import Solitude

type StyledDoc = PP.Doc PPTTY.AnsiStyle

data Saying :: Effect where
  SayDoc :: StyledDoc -&gt; Saying m ()

data MessageBuffer = MessageBuffer
  { _msgBufBuffer :: [StyledDoc] -- ^ Current messages held before flushing.
  , _msgBufStyle :: Maybe PPTTY.AnsiStyle -- ^ Current formatting; 'Nothing' = plain.
  , _msgBufContext :: [StyledDoc] -- ^ Possibly nested prefixes before every message.
  }

&lt;&lt;say-helpers&gt;&gt;
&lt;&lt;interpret-say&gt;&gt;

&lt;&lt;say-functions&gt;&gt;
</code></pre>
<p>We define our <code>Effect</code> to take a pretty-printed document. This does mean we almost never use the effect directly, but still. We also hold onto some message context - a style and some additional &quot;preface every entry with this&quot; text. If we're using the <code>IO</code> interpretation, then we just leave the buffer blank.</p>
<pre><code class="language-haskell id=say-helpers">blankMessageBuffer :: MessageBuffer
blankMessageBuffer = MessageBuffer [] Nothing []

makeEffect ''Saying
makeLenses ''MessageBuffer
</code></pre>
<h2 id="interpreting-saydoc"><a class="header" href="#interpreting-saydoc">Interpreting SayDoc</a></h2>
<p>Both interpreters do very similar things, with the difference being where the output ends up. We need a <code>MessageBuffer</code> to be present in the effect stack regardless to pre-process the doc by setting the style and amending any context.</p>
<pre><code class="language-haskell id=interpret-say">processDoc ::
  State MessageBuffer :&gt; es
  =&gt; StyledDoc
  -&gt; Eff es StyledDoc
processDoc msg = do
  (MessageBuffer _ style cxt) &lt;- get
  -- if we have no context, we just monoid it.
  let joinOp = case cxt of
        [] -&gt; (&lt;&gt;)
        _ -&gt; (PP.&lt;+&gt;)
  return $ PP.hcat cxt `joinOp` maybe id PP.annotate style msg

&lt;&lt;interpret-say-pure&gt;&gt;
&lt;&lt;interpret-say-io&gt;&gt;
</code></pre>
<p>And we can then interpret a <code>SayDoc</code> by amending to the buffer:</p>
<pre><code class="language-haskell id=interpret-say-pure">class Has s t where
  buf :: Lens' s t

type PartialState s t es = (Has s t, State s :&gt; es)

runSayPure ::
  forall s es. 
  PartialState s MessageBuffer es
  =&gt; Eff (Saying : es)
  ~&gt; Eff es
runSayPure = zoom (buf @s @MessageBuffer) . reinterpret \case
  SayDoc doc -&gt; do
    r &lt;- processDoc doc
    modify (\s -&gt; s &amp; msgBufBuffer %~ (r:))

</code></pre>
<p>or by dumping straight to <code>stdout</code>:</p>
<pre><code class="language-haskell id=interpret-say-io">runSayIO ::
  IOE :&gt; es
  =&gt; PartialState s MessageBuffer es
  =&gt; Eff (Saying : es)
  ~&gt; Eff es
runSayIO = zoom (buf @_ @MessageBuffer) . reinterpret \case
  SayDoc doc -&gt; do
    r &lt;- processDoc doc
    print r
</code></pre>
<h2 id="actually-saying-things"><a class="header" href="#actually-saying-things">Actually saying things</a></h2>
<p>And now we can write our <code>say</code> functions independent of whether we're in a pure or IO context. There's a handful of variations just because it's easier to do it all here.</p>
<pre><code class="language-haskell id=say-functions">-- | Say a string (well, Text).
say :: 
  Saying :&gt; es 
  =&gt; Text -- ^ Message.
  -&gt; Eff es ()
say = sayDoc . PP.pretty

-- | Say @message@ with a newline.
sayLn :: 
  Saying :&gt; es 
  =&gt; Text -- ^ Message.
  -&gt; Eff es ()
sayLn a = say (a &lt;&gt; &quot;\n&quot;)

-- | Conditionally say @message@.
sayIf :: 
  Saying :&gt; es 
  =&gt; Bool -- ^ Condition to evaluate.
  -&gt; Text -- ^ Message.
  -&gt; Eff es ()
sayIf True = say
sayIf False = const pass

-- | Update the style of a message buffer. Setting to 'Just' overwrites the style,
-- | whereas 'Nothing' will remove it. This will not affect previous messages.
setStyle :: 
  forall s es. 
  PartialState s MessageBuffer es
  =&gt; Maybe PPTTY.AnsiStyle -- ^ The updated style.
  -&gt; Eff es ()
setStyle s = buf @s @MessageBuffer % msgBufStyle .= s

{-
-- | Clear a message buffer and return the container (with a clean buffer)
-- with all formatting (e.g. ANSI colour codes) *included*.
flushBufferToStdOut :: 
  MonadIO m
  =&gt; HasBuffer w p 
  =&gt; Proxy p
  -&gt; w
  -&gt; m w
flushBufferToStdOut prox w = do
  let output' = (PPTTY.putDoc (comboBuffer w prox), w &amp; bufferL prox % msgBufBuffer .~ [])
  liftIO $ fst output'
  return (snd output')
  where
    comboBuffer d' p' = PP.hcat $ reverse $ d' ^. bufferL p' % msgBufBuffer
-}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>With the move from <code>mtl</code> to <code>cleff</code>, it was probably less effort to just write my own logging effect than to find how to get e.g. <a href="https://hackage.haskell.org/package/co-log"><code>co-log</code></a> working with an arbitrary effects system. Plus, I don't need that much of the fancy stuff it does? I just want a context and to write to many different places.</p>
<pre><code class="language-haskell file=src/Yaifl/Logger.hs">{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Logger where

import Solitude hiding ( trace, local, asks, Reader, runReader )
import Language.Haskell.TH ( Loc(..) )
import qualified Data.Text.Lazy.Builder as TLB
import Cleff.Trace ( trace, Trace )
import Cleff.Reader ( Reader, asks, local )
import Data.Text.Display ( display, Display, ShowInstance(..) )
import GHC.Stack
import Data.Time ( getCurrentTime, UTCTime )
import qualified Data.Aeson as A
import qualified Data.Text as T
import Katip.Format.Time ( formatAsLogTime )

&lt;&lt;log-effect&gt;&gt;
&lt;&lt;log-interpreters&gt;&gt;
&lt;&lt;log-functions&gt;&gt;
&lt;&lt;callstack-log&gt;&gt;
&lt;&lt;log-item&gt;&gt;
</code></pre>
<h2 id="logging-effect"><a class="header" href="#logging-effect">Logging Effect</a></h2>
<p>We only need two functions here, one to log a message of any severity (optionally with a callstack, stolen from <code>katip</code>) and another to make a contexted block (so we can have <code>[Some][Context][Here]</code> at the start of our lines in a hierarchal way). </p>
<pre><code class="language-haskell id=log-effect">data MsgSeverity = Debug | Info | Warning | Error
  deriving stock (Eq, Ord, Enum, Bounded, Show)
  deriving (Display) via (ShowInstance MsgSeverity)

data Log :: Effect where
  LogMsg :: Maybe Loc -&gt; MsgSeverity -&gt; Text -&gt; Log m () 
  WithContext :: Text -&gt; m a -&gt; Log m ()

makeEffect ''Log
</code></pre>
<h3 id="interpreters"><a class="header" href="#interpreters">Interpreters</a></h3>
<p>There already exist 3 different output-like effects in <code>cleff</code>; <code>Output</code> (for arbitrary <code>o</code>), <code>Trace</code> (which says it's for debugging logs), and <code>Writer</code> (which is even more general still). For the most flexibility, it's best to <code>reinterpret</code> our logging as a <code>Trace</code> effect (which has built-in interpreters to produce <code>Writer</code>s or <code>Output</code>s) with a <code>Reader</code> for the logging context. Of course, we may not want this <code>Reader</code> in the case we won't use it for anything (ignoring output) so we write our own ignore interpreter.</p>
<pre><code class="language-haskell id=log-interpreters">runAndIgnoreLogging :: 
  Eff (Log : es) 
  ~&gt; Eff es
runAndIgnoreLogging = interpret \case
  LogMsg _ _ _ -&gt; pass
  WithContext _ m -&gt; toEff $ void m

runLoggingAsTrace :: 
  [Reader [Text], IOE] :&gt;&gt; es 
  =&gt; Eff (Log : es) 
  ~&gt; Eff (Trace : es)
runLoggingAsTrace = reinterpret \case
  LogMsg mbLoc sev msg -&gt; do
    now &lt;- liftIO getCurrentTime
    cxt &lt;- asks reverse
    trace $ makeJSONObject now cxt sev mbLoc msg
  WithContext cxt m -&gt; void $ local (cxt:) (toEff m)

makeJSONObject :: UTCTime -&gt; [Text] -&gt; MsgSeverity -&gt; Maybe Loc -&gt; Text -&gt; String
makeJSONObject now cxt sev mbLoc pl = (decodeUtf8 $ A.encode $
  YaiflItem
  { itemSeverity = display sev
  , itemLoc = mbLoc
  , itemMessage = pl
  , itemTime = now
  , itemContext = cxt
  })
</code></pre>
<h2 id="extracting-callsite-info"><a class="header" href="#extracting-callsite-info">Extracting callsite info</a></h2>
<p>We try to extract the last callsite from some GHC <code>CallStack</code> and convert it to a <code>Loc</code>.</p>
<pre><code class="language-haskell id=callstack-log">toLoc :: 
  CallStack
  -&gt; Maybe Loc
toLoc stk = (listToMaybe . reverse $ getCallStack stk) &lt;&amp;&gt; \(_, loc) -&gt; 
  Loc
    { loc_filename = srcLocFile loc,
      loc_package = srcLocPackage loc,
      loc_module = srcLocModule loc,
      loc_start = (srcLocStartLine loc, srcLocStartCol loc),
      loc_end = (srcLocEndLine loc, srcLocEndCol loc)
    }
</code></pre>
<h2 id="logging-functions"><a class="header" href="#logging-functions">Logging Functions</a></h2>
<p>Each of our logging functions is a more concise way to log with a set severity and a callstack. This is inherently a structured logging format (perhaps in the future it'd be better to have the option of plaintext logging rather than explicitly and only JSON formatting) but JSON is what works nicely with <code>lnav</code>.</p>
<pre><code class="language-haskell id=log-functions">logInternal ::
  HasCallStack
  =&gt; Log :&gt; es
  =&gt; MsgSeverity
  -&gt; TLB.Builder
  -&gt; Eff es ()
logInternal sev msg = logMsg (toLoc callStack) sev (toText $ TLB.toLazyText msg)

debug :: 
  HasCallStack
  =&gt; Log :&gt; es
  =&gt; TLB.Builder
  -&gt; Eff es ()
debug = logInternal Debug

info :: 
  HasCallStack 
  =&gt; Log :&gt; es
  =&gt; TLB.Builder
  -&gt; Eff es ()
info = logInternal Info

warn :: 
  HasCallStack 
  =&gt; Log :&gt; es
  =&gt; TLB.Builder
  -&gt; Eff es ()
warn = logInternal Warning

err :: 
  HasCallStack 
  =&gt; Log :&gt; es
  =&gt; TLB.Builder
  -&gt; Eff es ()
err = logInternal Error
</code></pre>
<h2 id="structured-logging-at-last"><a class="header" href="#structured-logging-at-last">Structured logging, at last</a></h2>
<p>So we have everything done except the middle piece of glue that turns a logging message (probably with a callstack) into a JSON object. We need to relativise the filename to just <code>Foo.hs</code> and build the JSON object.</p>
<p>We use <code>katip</code> just because it has really nice time formatting that is nontrivial to repeat.</p>
<pre><code class="language-haskell id=log-item">
reshapeFilename :: 
  Loc 
  -&gt; String
reshapeFilename Loc{..} = drop 1 (dropWhile (/= '/') loc_filename) &lt;&gt; &quot;:&quot; &lt;&gt; show (fst loc_start) &lt;&gt; &quot;:&quot; &lt;&gt; show (snd loc_start)

data YaiflItem = YaiflItem
  { itemSeverity :: Text
  , itemMessage :: Text
  , itemTime :: UTCTime
  , itemContext :: [Text]
  , itemLoc :: Maybe Loc
  } deriving stock (Show, Eq)

instance A.ToJSON YaiflItem where
    toJSON (YaiflItem{..}) = A.object $
      [ &quot;level&quot; A..= itemSeverity
      , &quot;message&quot; A..= itemMessage
      , &quot;timestamp&quot; A..= formatAsLogTime itemTime
      , &quot;ns&quot; A..= let f = T.intercalate &quot;➤&quot; (filter (/= T.empty) $ itemContext) in if T.empty == f then &quot;&quot; else &quot;❬&quot;&lt;&gt;f&lt;&gt;&quot;❭&quot;
      , &quot;loc&quot; A..= fmap reshapeFilename itemLoc
      ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-world-model"><a class="header" href="#the-world-model">The World Model</a></h1>
<p>The <code>WorldModel</code> encompasses the spatial object model, as Inform's literate source puts it. This provides us with everything to specify the layout of the game world, the objects within it, and properties they have. For instance, <code>Thing</code>s and their <code>name</code> and <code>description</code> and <code>Room</code>s having <code>mapConnections</code>.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="worldmodel/typefamilies.html">WorldModel and WMx Type Families</a> - A neat trick to allow us to extensively parameterise our universes of types (<code>Objects</code>, <code>Directions</code>, <code>Values</code>, etc) without having to write out a dozen type parameters.</li>
<li><a href="worldmodel/state.html">The World State</a> - The record type that holds the game state.</li>
<li><a href="worldmodel/objects.html">Objects</a> - <code>Entity</code>, <code>Object</code>, <code>Store</code> and how these three types form the backbone of the lookup model.
<ul>
<li><a href="worldmodel/objects/entities-stores.html">Entities and Stores</a> - Spoilers: <code>newtype</code> wrappers around <code>Int</code>s and <code>newtype</code> wrappers around <code>newtype</code> wrappers around <code>IntMap</code> and making it slightly less painful to deal with object lookups.</li>
<li><a href="worldmodel/objects/things.html">Objects, Things and Rooms</a> - Probably the most important part, actual game objects.</li>
<li><a href="worldmodel/objects/reification.html">Reification</a> - Dealing with dynamic objects, because doing things as text substitutions is kind of awkward.</li>
<li><a href="worldmodel/objects/objectlike.html">ObjectLike</a> - Some helpers for things which act a bit like <code>Object</code>s, but aren't actually <code>Object</code>s (necessarily).</li>
<li><a href="worldmodel/objects/specifics-data.html">Object Specifics and Object Data</a> - The section that I could never remember the order of, the components that make <code>Thing</code>s things (<code>ObjectData</code>) and <code>Supporter</code>s supporters (<code>ObjectSpecifics</code>).</li>
</ul>
</li>
<li><a href="properties.html">Properties</a> - Smaller parts of <code>ObjectSpecifics</code> that can be shared by many types of <code>Object</code>.
<ul>
<li><a href="properties/getsetmodify.html">Get, Set, Modify</a> - <code>TemplateHaskell</code> to define our lookup functions. </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worldmodel-and-wmx-type-families"><a class="header" href="#worldmodel-and-wmx-type-families">WorldModel and WMx Type Families</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>One thing that has repeatedly annoyed me when trying to hack around on <code>yaifl</code> is the desire to be as general as possible, but whilst doing my best to avoid writing imperative code but in Haskell. One of these major headscratching problems was how to have something akin to extensible records but in a more Haskell-y way. For instance, take object types. We can provide a standard library of <code>Thing</code>, <code>Room</code>, <code>Door</code>, <code>Person</code>, <code>Vehicle</code>, etc. just fine; but what if we want to have a <code>Gate</code>? In an OO- language this is fine - just inherit from <code>Door</code>. In Haskell we can approximate this in the same way <code>Parsec</code> deals with its error types:</p>
<pre><code class="language-haskell">
data ObjectType a = ThingType Thing | DoorType Door | RoomType Room ... | Other a
</code></pre>
<p>And we are then open (as long as the user supplied <code>a</code> satisfies constraints that we impose, such as <code>Show</code> or <code>Eq</code>) to extensionality but closed at compile time. This has the drawback that if you want this open-closed hierarchy on <em>many</em> types of data, you have a monolithic state that
looks something like <code>MonolithicState a b c d e f g</code>:</p>
<ul>
<li>We want horizontally extendable object types, so we can start with <code>MonolithicWorld objType</code>. All cool.</li>
<li>Now we want directions; whilst the compass points are probably fine for nearly every game, sometimes you might want to have turnwise or widdershins. Now you have <code>MonolithicWorld objType directionType</code>. </li>
<li>What about arbitrary data variables you want to keep track of during the game? Now you've got <code>MonolithicWorld objType directionType variableRecord</code>. </li>
<li>And so on.</li>
</ul>
<p>Chances are that most of those are going to be <code>()</code> - you don't want extra directions, or you don't define a special kind of door - but it's a huge pain to write out multiple times for each function signature.</p>
<p>We could work in an <code>mtl</code>-style way of component instances and typeclasses:</p>
<pre><code class="language-haskell">data MonolithicWorld s = MonolithicWorld
  { ...
  , worldData :: s
  }

data WorldData a b c d e f g = WorldData
  { things :: Store (Object a)
  , directions :: Store (Direction b)
  ...
  -- and so on
  }

class HasThings s a where
  things :: Lens' (MonolithicWorld s) (Store (Object a))

class HasDirections s b where
  directions :: Lens' (MonolithicWorld s) (Store (Direction b))
</code></pre>
<p>But this quickly ran into the same problem; a function that dealt with both <code>Direction</code>s and <code>Object</code>s still needs both <code>a</code> and <code>b</code> to be parametric, and these constraints bubbled up to the top...plus, I'd often get <code>ambiguous type variable a1</code> issues.</p>
<p>What if there was a way to do this with some type-level nonsense?</p>
<h2 id="the-worldmodel-type-families"><a class="header" href="#the-worldmodel-type-families">The WorldModel type families</a></h2>
<p>Behold, a whole bunch of random <code>Type</code>s!</p>
<pre><code class="language-haskell id=world-model">data WorldModel = WorldModel Type Type Type Type
</code></pre>
<p>By using <code>DataKinds</code>, we can promote this to the type level. We can now start making types that look like</p>
<pre><code class="language-haskell">data SomeExtraObjTypes = GateType Gate
type Score = Int
type AWorldModel = 'WorldModel SomeExtraObjTypes () () Score
</code></pre>
<p>which is great; we can parameterise everything by <code>(wm :: WorldModel)</code>, and now we have only one type variable instead of 4 (or more)! But record field accessors don't work at the type-level (F in chat), so we need to write a little boilerplate:</p>
<pre><code class="language-haskell id=world-model-families">type family WMObjSpecifics (wm :: WorldModel) :: Type where
  WMObjSpecifics ('WorldModel objSpec dir o v) = objSpec

type family WMDirections (wm :: WorldModel) :: Type where
  WMDirections ('WorldModel objSpec dir o v) = dir 

type family WMValues (wm :: WorldModel) :: Type where
  WMValues ('WorldModel objSpec dir o v) = o
</code></pre>
<p>How does this work? Without doing a terrible job of massacring an explanation of how type families work, we can view these as very basic dependent types; given some type instantiation of <code>wm :: WorldModel</code>, we have an associated type <code>WMObjSpecifics</code> that is defined by the first member of that type. Now, rather than ever referring to the <code>objSpec</code> we can refer to <code>WMObjSpecifics wm</code>. Everything is unified and there's no unnecessary typeclass baggage, rejoice!</p>
<p>Well, there is one slight issue - this breaks GHC's <code>deriving</code> machinery. Types that contain a <code>WMFoo wm</code> have to instead use quantified instance derivations; for instance we may need to define an <code>Ord</code> instance like</p>
<pre><code class="language-haskell">deriving stock instance (Ord (WMDirections wm), Ord (WMObjSpecifics wm)) =&gt; Ord (FooBar wm)
</code></pre>
<p>which gets minorly annoying. But thanks to <code>ConstraintKinds</code> we can write some tidy helper types.</p>
<pre><code class="language-haskell id=world-model-constraints">type WMConstr (c :: Type -&gt; Constraint) wm = (c (WMObjSpecifics wm), c (WMValues wm), c (WMDirections wm))
type WMShow wm = WMConstr Show wm
type WMRead wm = WMConstr Read wm
type WMOrd wm = WMConstr Ord wm
type WMEq wm = WMConstr Eq wm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>This chapter contains 3 main parts:</p>
<ul>
<li><strong>Entities</strong> - An ID that allows us to circumvent immutability by breaking apart references between objects.</li>
<li><strong>Stores</strong> - <code>Map</code>s of <code>Entity</code>s to various objects.</li>
<li><strong>Objects</strong> - Game objects, spanning from the physical (keys, doors, people) to the intangible (rooms, etc).</li>
</ul>
<p>Between these 3, we can construct (with some difficulty) a world model that can represent some domain of IF, but not one that can be interacted with -- yet.</p>
<h3 id="brief-comments-on-some-other-systems"><a class="header" href="#brief-comments-on-some-other-systems">Brief comments on some other systems</a></h3>
<p>There's certainly a couple of other ways to approach this idea (that aren't &quot;just write in OOP&quot;), which I figured were worth mentioning.</p>
<ul>
<li><strong>Entity-component systems (ECS)</strong> - these are certainly doable in Haskell - <code>ecstasy</code> and <code>apecs</code> come to mind, and to some degree we are designing an ECS that cannot change at runtime - but it's not great because the semantic approach is that you want to iterate over sets of <em>components</em> and less so care about what they are attached to -- this is the exact opposite to a text adventure (where you rarely care about <em>all</em> doors or vehicles or whatever, rather just a specific one).</li>
<li><strong>Ad-hoc, extensible records</strong> - By which I mean some sort of system where there is no distinction between discrete classes of kinds, but rather everything is an anonymous record (plus/minus some type-wizardry) with named fields. This would probably be a good option, but I felt it un-idiomatic. </li>
</ul>
<h3 id="aims-of-the-entitystoremodel-structure"><a class="header" href="#aims-of-the-entitystoremodel-structure">Aims of the Entity/Store/Model structure</a></h3>
<ul>
<li>Everything should be Haskell-ish. Whilst the use of <code>lens</code> (or in this case, <code>optics</code>) is almost a given for a program that works so heavily on nested data structure modification, and it being a &quot;game&quot; implies the existence of some monolithic state, I would like to be able to work in pure functions where possible.</li>
<li>Everything should be extensible with minimal effort. Any more direct way to include such semantics as &quot;A thing can be sticky or not sticky. A thing is usually sticky&quot; as modifying the very concept of a <code>Thing</code> is getting into dynamic typing territory. Rather, by utilising smart constructors, we can write simple wrappers of <code>makeStickyThing</code> that use <code>ObjectSpecifics</code> that look like <code>(Stickiness, a)</code> and <em>voila</em>, we have redefined every <code>Thing</code> in the program. NB: this does mean there needs to be some care taken when we automatically generate objects and rooms (the player, the void).</li>
<li>Type safety. It makes no sense to call <code>move</code> on a <code>Room</code> and a <code>Scenery</code>, for instance.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-and-stores"><a class="header" href="#entities-and-stores">Entities and Stores</a></h1>
<p>By decentralising references between objects and instead storing some kind of ID and some kind of <code>Map ID Object</code>, we can avoid mutable state. Hooray!</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<pre><code class="language-haskell id=entity-def">newtype Entity = Entity
  { unID :: Int
  } deriving stock   (Show, Generic)
    deriving newtype (Eq, Num, Read, Bounded, Hashable, Enum, Ord, Real, Integral)
</code></pre>
<p>A <code>newtype</code> wrapper around  <code>Int</code>. Yup, that's about it. One nice feature is that we can, under the assumption
that nobody does something strange (like turning a <code>Thing</code> into a <code>Room</code>), determine whether a given <code>Entity</code> 
refers to a <code>Thing</code> or a <code>Room</code> by whether we generated the ID by counting up or down:</p>
<pre><code class="language-haskell id=thing-or-room">isThing ::
  (HasID a)
  =&gt; a
  -&gt; Bool
isThing a = getID a &gt;= 0

isRoom ::
  (HasID a)
  =&gt; a
  -&gt; Bool
isRoom = not . isThing
</code></pre>
<p>It's also nice to have a way to always get an <code>Entity</code> from a construct:</p>
<pre><code class="language-haskell id=has-id">class HasID n where
  getID :: n -&gt; Entity

instance HasID Entity where
  getID = id

instance Display Entity where
  display (Entity i) = &quot;ID: &quot; &lt;&gt; show i

</code></pre>
<p>We also then reserve a few IDs for the 'default' objects which we never want to see at runtime, but need at construction time to avoid unnecessary <code>Maybe</code>s.</p>
<pre><code class="language-haskell id=base-ids">defaultVoidID :: Entity
defaultVoidID = Entity (-1)

defaultNothingID :: Entity
defaultNothingID = Entity 0

defaultPlayerID :: Entity
defaultPlayerID = Entity 1
</code></pre>
<h2 id="stores"><a class="header" href="#stores">Stores</a></h2>
<p>A <code>Store</code> is a map from <code>Entity</code>s to <code>a</code>s. Usually this is some flavour of <code>Object wm d</code>, but we can also use
<code>Store (Entity, Payload)</code> for relations and things like that. Of course, since I've refactored the direct link of a <code>Map</code>-based store to a specific interpretation of the world's effects, this seems slightly out of place. But it's fairly obvious as the go-to implementation so it may as well stay here.</p>
<pre><code class="language-haskell id=store-def">-- import qualified Data.EnumMap.Strict as EM
newtype Store a = Store
  { unStore :: EM.EnumMap Entity a
  } deriving stock   (Show, Generic)
    deriving newtype (Eq, Ord, Read)

emptyStore :: Store a
emptyStore = Store EM.empty
</code></pre>
<h3 id="enummap-and-optics"><a class="header" href="#enummap-and-optics">EnumMap and Optics</a></h3>
<p><code>EnumMap</code> (and its sibling <code>EnumSet</code>) are nice convenient <code>newtype</code> wrappers around <code>IntMap</code>, but they're not
quite cut out for a) <em>further</em> <code>newtype</code> wrappers around <em>them</em>, and b) the instances for nice <code>Lens</code>/<code>Optics</code> things.</p>
<p>First let's define our own <a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#v:alterF"><code>alterF</code></a> for <code>EnumMap</code> and then <em>another</em> for a <code>newtype</code> wrapper...</p>
<pre><code class="language-haskell id=alter-store">alterEMF :: 
  (Functor f, Enum k)
  =&gt; (Maybe a -&gt; f (Maybe a))
  -&gt; k
  -&gt; EM.EnumMap k a 
  -&gt; f (EM.EnumMap k a)
alterEMF upd k m = EM.intMapToEnumMap &lt;$&gt; IM.alterF upd (fromEnum k) (EM.enumMapToIntMap m)

alterNewtypeEMF :: 
  (Functor f, Enum k)
  =&gt; (Maybe a -&gt; f (Maybe a))
  -&gt; k
  -&gt; (nt -&gt; EM.EnumMap k a)
  -&gt; (EM.EnumMap k a -&gt; nt)
  -&gt; nt
  -&gt; f nt
alterNewtypeEMF upd k unwrap wrap' m = wrap' &lt;$&gt; alterEMF upd k (unwrap m)
</code></pre>
<p>Which we can now use for a nice and tidy <code>At</code> instance.</p>
<pre><code class="language-haskell id=store-at">instance At (Store a) where
  at k = lensVL $ \f -&gt; alterNewtypeEMF f k unStore Store
</code></pre>
<p>Finally, we choose the obvious instantiations for the associated index types.</p>
<pre><code class="language-haskell id=store-instances">type instance IxValue (Store a) = a
type instance Index (Store a) = Entity
instance Ixed (Store a)
</code></pre>
<p>Which means we can now write use our lenses as <code>someStore ^? at someEntity</code> rather than <code>someStore ^? coercedTo @(EnumMap Entity a) % to unStore % at someEntity</code>, or some other verbose beast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects-1"><a class="header" href="#objects-1">Objects</a></h1>
<p>And now we turn to the final of the foundational parts of the world model, the <code>Object</code>. Whilst we don't go quite as far as
Inform does, where <em>everything</em> is an object of some kind (including directions, or if you wanted to extend the system with ideas such as people having knowledge of something), we still consider most things in a game to be an <code>Object</code> of some kind. These can be split into two categories; <code>Thing</code>s (physical, interactable, objects) and <code>Room</code>s (spaces to be moved between). </p>
<p>Each of these can be further divided into more specific instances, but it is significantly simpler to deal with everything being either a realisable object or a space, and treat the very few intangible objects as their own specific thing (for example, directions). The obvious downside of this is that we have to treat directions specially -- but since when has anyone written a piece of IF where they need to invent new directions <em>at runtime</em>? </p>
<p>First we have the overview of the module.</p>
<pre><code class="language-haskell file=src/Yaifl/Objects/Object.hs">{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableInstances #-}

module Yaifl.Objects.Object ( 
  -- * Types
  ObjType(..)
  , Object(..)
  , Thing
  , Room
  , AnyObject
  -- * Object Helpers
  , objectEquals
  -- * Lenses
  , objName, objDescription, objID, objType
  , objCreationTime, objSpecifics, objData
  -- * Prisms
  , _Room, _Thing ) where

import Solitude
import Yaifl.Common ( WMObjSpecifics, Timestamp, HasID(..), Entity )
import Yaifl.Objects.ObjectData ( RoomData, ThingData )
import Yaifl.Objects.Specifics ( ObjectSpecifics )

&lt;&lt;obj-type&gt;&gt;
&lt;&lt;thing-room-anyobject&gt;&gt;
&lt;&lt;obj-definition&gt;&gt;
&lt;&lt;obj-hasid&gt;&gt;
&lt;&lt;obj-eq&gt;&gt;
makeLenses ''Object
&lt;&lt;obj-functor&gt;&gt;

&lt;&lt;obj-prisms&gt;&gt;
&lt;&lt;can-be-any&gt;&gt;
</code></pre>
<p>And the object type itself:</p>
<pre><code class="language-haskell id=obj-definition">data Object wm objData = Object
  { _objName :: !Text
  , _objDescription :: !Text
  , _objID :: !Entity
  , _objType :: !ObjType
  , _objCreationTime :: !Timestamp
  , _objSpecifics :: !(Either ObjectSpecifics (WMObjSpecifics wm))
  , _objData :: !objData
  } deriving stock (Generic)

deriving stock instance (Show (WMObjSpecifics wm), Show d) =&gt; Show (Object wm d)
deriving stock instance (Read (WMObjSpecifics wm), Read d) =&gt; Read (Object wm d)
</code></pre>
<p>So there's a handful of things here:</p>
<ul>
<li><code>Object</code>s are parameterised by two type parameters; <code>wm :: WorldModel</code>, which we use to define the extensions of <code>ObjectSpecifics</code> (to be discussed below), and <code>objData</code>, which will always be one of 3 types:
<ul>
<li><code>ThingData wm</code>, and we have a <code>Thing</code>;</li>
<li><code>RoomData wm</code>, and we have a <code>Room</code>;</li>
<li><code>Either (ThingData wm) (RoomData wm)</code>, and we have no idea which so we call it <code>AnyObject</code>.
<code>ThingData</code> and <code>ObjectData</code> are covered in <a href="worldmodel/objects/data.html">the next section</a></li>
</ul>
</li>
<li>Yes, everything is prefixed with an underscore because we use a <em>lot</em> of lens TH generation.</li>
<li>This is the first of many standalone deriving instances. Will we ever need <code>Read (Object wm d)</code>? Probably not, but still.</li>
</ul>
<h2 id="some-useful-instances"><a class="header" href="#some-useful-instances">Some useful instances</a></h2>
<p>Obviously we can get an <code>ID</code> out of an <code>Object</code>:</p>
<pre><code class="language-haskell id=obj-hasid">instance HasID (Object wm d) where
  getID = _objID
</code></pre>
<p>The other obvious missing one is <code>Eq</code>; if we automatically derive <code>Eq</code>, we can only compare objects with the same <code>objData</code> type -- so no comparison at all of <code>Room</code>s and <code>Thing</code>s (even if that's always <code>False</code>) or even <code>Thing</code>s and <code>AnyObject</code>s (which may be true). So we write our own that is slightly more lenient on the types, and <code>Ord</code> too even though it makes no sense.</p>
<pre><code class="language-haskell id=obj-eq">objectEquals :: 
  Object wm d
  -&gt; Object wm d'
  -&gt; Bool
objectEquals = (. _objID) . (==) . _objID

instance Eq (Object wm d) where
  (==) = objectEquals

-- | Maybe I'll need this instance for something or other? 
instance Ord (Object wm d) where
  compare = (. _objID) . compare . _objID
</code></pre>
<p>Another fairly useful set of instances that don't make a huge amount of sense for anything other than ease of use: <code>Functor</code>, <code>Foldable</code>, and <code>Traversable</code>. All 3 work over <code>objData</code>, so the primary use is to go back-and-forth from <code>AnyObject</code>.</p>
<pre><code class="language-haskell id=obj-functor">instance Functor (Object wm) where
  fmap :: 
    (a -&gt; b)
    -&gt; Object wm a
    -&gt; Object wm b
  fmap f = objData %~ f

instance Foldable (Object wm) where
  foldMap :: 
    (a -&gt; m)
    -&gt; Object wm a 
    -&gt; m
  foldMap f = f . _objData

instance Traversable (Object wm) where
  traverse :: 
    Applicative f 
    =&gt; (a -&gt; f b) 
    -&gt; Object wm a 
    -&gt; f (Object wm b)
  traverse f o = (\v -&gt; o {_objData = v}) &lt;$&gt; f (_objData o)
</code></pre>
<h2 id="object-types"><a class="header" href="#object-types">Object Types</a></h2>
<p><code>ObjType</code> may look strange given how much we are trying to avoid remaking OO here, but this use of an object &quot;type&quot; is more of a tag system:</p>
<pre><code class="language-haskell id=obj-type">newtype ObjType = ObjType
  { unObjType :: Text
  } deriving stock (Eq, Show)
    deriving newtype (Read, Ord, IsList, IsString, Monoid, Semigroup)
</code></pre>
<p><code>ObjType</code>s make a DAG that approximates inheritance in name only. For instance, we may wish to check that an object <em>is</em> a supporter for printing locale descriptions (where we want to say &quot;on the table&quot; rather than &quot;in the table&quot;). We aren't being polymorphic and imitating v-tables, or deriving properties automatically - we just note that &quot;supporter&quot; is a valid object type and e.g. a &quot;display cabinet&quot; is also a kind of supporter, and a &quot;glass fronted display cabinet&quot; is a kind of display cabinet and we can infer the transitive property.</p>
<hr />
<h2 id="things-rooms-anyobjects"><a class="header" href="#things-rooms-anyobjects">Things, Rooms, AnyObjects</a></h2>
<p>And at last, we can talk about <code>Thing</code>, <code>Room</code>, and <code>AnyObject</code>:</p>
<pre><code class="language-haskell id=thing-room-anyobject">type Thing wm = Object wm ThingData
type Room wm = Object wm (RoomData wm)
type AnyObject wm = Object wm (Either ThingData (RoomData wm))
</code></pre>
<h3 id="lenses-and-prisms"><a class="header" href="#lenses-and-prisms">Lenses and Prisms</a></h3>
<p>For the most part I'm omitting fluff like <code>makeLenses ''Object</code> (if you're really interested, they will be in the full <code>noweb</code> file in the <code>Reference</code> section). However there are two very useful prisms we can define. Originally, these were their own typeclass called <code>CanBeAny</code> - because they looked like </p>
<pre><code class="language-haskell">toAny :: a -&gt; b
fromAny :: b -&gt; Maybe a
</code></pre>
<p>but then I realised these were just <code>preview</code> and <code>review</code> respectively. There is an equivalent for <code>AbstractObject</code> as well, though whether it's useful isn't yet decided.</p>
<pre><code class="language-haskell id=obj-prisms">_Room :: Prism' (AnyObject wm) (Room wm)
_Room = prism' (fmap Right) (traverse rightToMaybe)

_Thing :: Prism' (AnyObject wm) (Thing wm)
_Thing = prism' (fmap Left) (traverse leftToMaybe)
</code></pre>
<p>Though I keep the class around regardless, because <code>toAny o</code> makes more semantic sense than <code>review _Thing</code>.</p>
<pre><code class="language-haskell id=can-be-any">class CanBeAny wm o where
  toAny :: o -&gt; AnyObject wm
  fromAny :: AnyObject wm -&gt; Maybe o

instance CanBeAny wm (Room wm) where
  toAny = review _Room
  fromAny = preview _Room

instance CanBeAny wm (Thing wm) where
  toAny = review _Thing
  fromAny = preview _Thing

instance CanBeAny wm (AnyObject wm) where
  toAny = id
  fromAny = Just
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-querying-effects"><a class="header" href="#object-querying-effects">Object Querying Effects</a></h1>
<p>This is an excellent example of how smaller effects mean less boilerplate over the equivalent mtl solution. I think. At least it certainly avoid the O(n^2) instances that come from having a <code>ObjectRead</code>, <code>ObjectWrite</code>, <code>ObjectQuery</code>, etc set of constraints.</p>
<pre><code class="language-haskell file=src/Yaifl/Objects/Query.hs">{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Objects.Query
  ( -- * Types
  ObjectLike(..)
  , MissingObject(..)
  , ObjectQuery(..)
  -- * Missing Objects
  , withoutMissingObjects 
  , failHorriblyIfMissing
  , handleMissingObject
  , NoMissingObjects
  -- * Get
  , lookupThing
  , lookupRoom
  , getObject
  , getThingMaybe
  , getRoomMaybe
  , asThingOrRoom
  -- * Modify
  , modifyObject
  , modifyThing
  , modifyRoom
  -- * Set
  , setThing
  , setRoom
  ) where

import Cleff.Error ( Error, fromEither, runError, throwError )
import Cleff.State ( State )
import qualified Data.Text.Lazy.Builder as TLB

import Solitude

import Yaifl.Common ( Metadata, WorldModel, HasID(..), Entity, isThing )
import Yaifl.Logger ( Log, err )
import Yaifl.Objects.Object ( _Room, _Thing, AnyObject, Object(_objID), Room, Thing )

&lt;&lt;missing-object&gt;&gt;
&lt;&lt;handle-missing-objects&gt;&gt;
&lt;&lt;object-query-effect&gt;&gt;
&lt;&lt;objectlike&gt;&gt;
&lt;&lt;objectlike-instances&gt;&gt;
&lt;&lt;get-objects&gt;&gt;
&lt;&lt;modify-objects&gt;&gt;
</code></pre>
<h2 id="missing-objects"><a class="header" href="#missing-objects">Missing Objects</a></h2>
<p>It's much easier to use some kind of <code>Error</code> effect to avoid wrapping endless amounts of object querying in <code>Maybe</code>. We start with a simple payload that holds whatever object was looked for (and failed to find), and some contextual error message.</p>
<pre><code class="language-haskell id=missing-object">data MissingObject = MissingObject 
  { _moExpected :: Text
  , _moEntity :: Entity
  } deriving stock (Eq, Show, Read, Ord, Generic)

makeLenses ''MissingObject
</code></pre>
<pre><code class="language-haskell id=handle-missing-objects">withoutMissingObjects :: 
  (HasCallStack =&gt; Eff (Error MissingObject ': es) a) -- ^ the block
  -&gt; (HasCallStack =&gt; MissingObject -&gt; Eff es a)  -- ^ the handler
  -&gt; Eff es a
withoutMissingObjects f def = do
  r &lt;- runError f
  case r of
    Left err' -&gt; def err'
    Right x -&gt; return x

handleMissingObject :: 
  HasCallStack
  =&gt; Log :&gt; es
  =&gt; TLB.Builder 
  -&gt; Eff es a 
  -&gt; MissingObject
  -&gt; Eff es a
handleMissingObject msg def (MissingObject t o) = do
  err (msg &lt;&gt; bformat (stext %! &quot;; Object ID: &quot; %! stext) t (show o))
  def

failHorriblyIfMissing ::
  Log :&gt; es
  =&gt; (HasCallStack =&gt; Eff (Error MissingObject ': es) a)
  -&gt; Eff es a
failHorriblyIfMissing f = withoutMissingObjects f (\(MissingObject t o) -&gt; do
  let msg = &quot;Failing horribly and erroring out because we can't recover&quot;
      emsg = msg &lt;&gt; bformat (stext %! &quot;; Object ID: &quot; %! stext) t (show o)
  err emsg
  error $ show emsg)
</code></pre>
<h2 id="object-querying"><a class="header" href="#object-querying">Object querying</a></h2>
<p>And now we have the effects themselves. A write-only effect wouldn't be particularly useful, and similarly there's not a great use-case for thing-only or room-only. We return <code>Either</code> in the <code>lookup</code> functions because we have multiple possible fail cases (when we are reifying dynamic objects as well as the expected failed lookup). The <code>Either</code> is consumed by higher-level functions, so we probably never use <code>lookup</code> directly.</p>
<pre><code class="language-haskell id=object-query-effect">data ObjectQuery (wm :: WorldModel) :: Effect where
  LookupThing :: HasID o =&gt; o -&gt; ObjectQuery wm m (Either Text (Thing wm))
  LookupRoom :: HasID o =&gt; o -&gt; ObjectQuery wm m (Either Text (Room wm))
  SetRoom :: Room wm -&gt; ObjectQuery wm m ()
  SetThing :: Thing wm -&gt; ObjectQuery wm m ()

makeEffect ''ObjectQuery

type NoMissingObjects wm es = (Error MissingObject :&gt; es, ObjectQuery wm :&gt; es, State (Metadata wm) :&gt; es) 
</code></pre>
<h2 id="objectlike"><a class="header" href="#objectlike">ObjectLike</a></h2>
<p>A slight detour to things which are <em>almost</em> objects but require looking up extra information in the effect stack. This is slightly more restrictive than <code>HasID</code>.</p>
<pre><code class="language-haskell id=objectlike">class HasID o =&gt; ObjectLike wm o where
  getRoom :: NoMissingObjects wm es =&gt; o -&gt; Eff es (Room wm)
  default getRoom :: NoMissingObjects wm es =&gt; o -&gt; Eff es (Room wm)
  getRoom o = throwError $ MissingObject &quot;Called getRoom on an object with no instance.&quot;  (getID o)

  getThing :: NoMissingObjects wm es =&gt; o -&gt; Eff es (Thing wm)
  default getThing :: (NoMissingObjects wm es) =&gt; o -&gt; Eff es (Thing wm)
  getThing o = throwError $ MissingObject &quot;Called getThing on an object with no instance.&quot;  (getID o)
</code></pre>
<p>And we have the obvious instances for <code>Object</code>s themselves, to eliminate the <code>Either</code> out of an <code>AnyObject</code>, and the sneakily most important instance that wraps <code>lookup</code> with removing the fail case.</p>
<pre><code class="language-haskell id=objectlike-instances">instance ObjectLike wm (Thing wm) where
  getThing = pure

instance ObjectLike wm (Room wm) where
  getRoom = pure

instance ObjectLike wm (AnyObject wm) where
  getThing t = fromEither
    (maybeToRight (MissingObject (&quot;Tried to get a thing from &quot; &lt;&gt; show (_objID t) &lt;&gt; &quot; but it was a room.&quot;) (getID t))
      (preview _Thing t))
  getRoom t = fromEither
    (maybeToRight (MissingObject (&quot;Tried to get a room from &quot; &lt;&gt; show (_objID t) &lt;&gt; &quot; but it was a thing.&quot;) (getID t))
      (preview _Room t))

instance ObjectLike wm Entity where
  getRoom e = lookupRoom e &gt;&gt;= either (throwError . flip MissingObject e) return
  getThing e = lookupThing e &gt;&gt;= either (throwError . flip MissingObject e) return
</code></pre>
<p>Most of the <code>get</code> functionality is in <code>ObjectLike</code>, but we have a couple of useful functions here:</p>
<ul>
<li>if we don't know the type of an object (and it's irrelevant enough to not bother querying the ID type at the call site), we can just get <code>AnyObject</code>.</li>
<li>sometimes we don't want to throw an error or deal with <code>NoMissingObjects</code> blocks, so we can wrap it back into a <code>Maybe</code>.</li>
<li>Finally we can do coproduct elimination by handling both cases of an <code>Object</code>.</li>
</ul>
<pre><code class="language-haskell id=get-objects">getObject ::
  NoMissingObjects wm es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; Eff es (AnyObject wm)
getObject e = if isThing e
  then (review _Thing &lt;$&gt; getThing e)
  else (review _Room &lt;$&gt; getRoom e)

getThingMaybe :: 
  ObjectQuery wm :&gt; es
  =&gt; State (Metadata wm) :&gt; es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; Eff es (Maybe (Thing wm))
getThingMaybe o = withoutMissingObjects (getThing o &lt;&amp;&gt; Just) (const (return Nothing))

getRoomMaybe ::
  ObjectQuery wm :&gt; es
  =&gt; State (Metadata wm) :&gt; es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; Eff es (Maybe (Room wm))
getRoomMaybe o = withoutMissingObjects (getRoom o &lt;&amp;&gt; Just) (const (return Nothing))

asThingOrRoom :: 
  NoMissingObjects wm es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; (Thing wm -&gt; a)
  -&gt; (Room wm -&gt; a)
  -&gt; Eff es a
asThingOrRoom o tf rf =
  if isThing o
  then tf &lt;$&gt; getThing o
  else rf &lt;$&gt; getRoom o
</code></pre>
<h2 id="modifying-objects"><a class="header" href="#modifying-objects">Modifying Objects</a></h2>
<p>For modifying, we have a helper function that is basically a verbose and law-breaking lens and then modifying specific objects is simply a curried version. The awkward case is modifying an <code>AnyObject</code> because technically the object <em>could</em> switch from <code>Thing</code> to <code>Room</code> in the middle but we trust that not to happen.</p>
<pre><code class="language-haskell id=modify-objects">modifyObjectFrom :: 
  (o -&gt; Eff es (Object wm any))
  -&gt; (Object wm any -&gt; Eff es ())
  -&gt; o
  -&gt; (Object wm any -&gt; Object wm any)
  -&gt; Eff es ()
modifyObjectFrom g s o u = do
  obj &lt;- g o
  s (u obj)
  pass

modifyThing :: 
  NoMissingObjects wm es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; (Thing wm -&gt; Thing wm)
  -&gt; Eff es ()
modifyThing = modifyObjectFrom getThing setThing 

modifyRoom ::
  NoMissingObjects wm es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; (Room wm -&gt; Room wm)
  -&gt; Eff es ()
modifyRoom = modifyObjectFrom getRoom setRoom

modifyObject ::
  NoMissingObjects wm es
  =&gt; ObjectLike wm o
  =&gt; o
  -&gt; (AnyObject wm -&gt; AnyObject wm)
  -&gt; Eff es ()
modifyObject e s = 
  if isThing e
  then modifyThing e (anyModifyToThing s)
  else modifyRoom e (anyModifyToRoom s)

anyModifyToThing :: 
  (AnyObject s -&gt; AnyObject s)
  -&gt; (Thing s -&gt; Thing s)
anyModifyToThing f t = fromMaybe t (preview _Thing $ f (review _Thing t))

anyModifyToRoom :: 
  (AnyObject s -&gt; AnyObject s)
  -&gt; (Room s -&gt; Room s)
anyModifyToRoom f t = fromMaybe t (preview _Room $ f (review _Room t))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objectdata"><a class="header" href="#objectdata">ObjectData</a></h1>
<p>This is where we differentiate between <code>Thing</code>s and <code>Room</code>s. Object data is those properties which are common (and then objects are further specialised with object specifics). For instance, <code>Room</code>s will always have <code>mapConnections</code> but never <code>edibility</code>.</p>
<p>We start with the module overview:</p>
<pre><code class="language-haskell file=src/Yaifl/Objects/ObjectData.hs">{-# LANGUAGE StrictData #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableInstances #-}

module Yaifl.Objects.ObjectData
  ( -- * Things
    ThingLit(..)
  , ThingWearability(..)
  , ThingDescribed(..)
  , ThingData(..)
  , blankThingData

  -- * Rooms
  , MapConnections(..)
  , ContainingRegion(..)
  , Darkness(..)
  , RoomData(..)
  , ConnectionExplicitness(..)
  , Connection(..)
  , blankRoomData

  -- * Lenses
  , thingContainedBy, thingLit, thingWearable, thingDescribed, _Wearable
  , roomIsVisited, roomDarkness, roomMapConnections, roomContainingRegion, roomEnclosing

  , connectionExplicitness, connectionRoom
  ) where

import qualified Data.Map as Map
import Solitude 
import Yaifl.Common ( WMDirections, Entity, defaultVoidID )
import Yaifl.Properties.Enclosing ( Enclosing, blankEnclosing )

&lt;&lt;thing-data&gt;&gt;
&lt;&lt;connections&gt;&gt;
&lt;&lt;room-data&gt;&gt;
</code></pre>
<h1 id="things"><a class="header" href="#things">Things</a></h1>
<p>We have a bunch of fancy boolean flags. The special case is <code>ThingWearability</code>, where we wish to track both its ability to be worn and if it is worn then additionally who (maybe) is wearing it.</p>
<pre><code class="language-haskell id=thing-data">-- | If a thing provides light outwards; A lamp is lit, but a closed box with a light inside is not.
data ThingLit = Lit | NotLit 
  deriving stock (Eq, Show, Read, Enum, Ord, Generic)

-- | If a thing is wearable, and if so who (or what) is currently wearing it.
data ThingWearability = NotWearable | Wearable (Maybe Entity) 
  deriving stock (Eq, Show, Read, Ord, Generic)

-- | If a thing appears in &quot;You can also see...&quot; paragraphs.
data ThingDescribed = Undescribed | Described 
  deriving stock (Eq, Show, Read, Enum, Ord, Generic)

data ThingData = ThingData
  { _thingContainedBy :: Entity
  , _thingLit :: ThingLit
  , _thingWearable :: ThingWearability
  , _thingDescribed :: ThingDescribed
  } deriving stock (Eq, Show, Read, Ord, Generic)

blankThingData :: ThingData
blankThingData = ThingData defaultVoidID NotLit NotWearable Described

makeLenses ''ThingData
makePrisms ''ThingWearability
</code></pre>
<h1 id="rooms"><a class="header" href="#rooms">Rooms</a></h1>
<h2 id="connections"><a class="header" href="#connections">Connections</a></h2>
<p>We formalise connections between rooms somewhat. <code>Inform7</code> has an (implicit) notion of connections, in that it will make the reverse mapping relation if it doesn't disturb something you have explicitly made already. For instance:</p>
<pre><code class="language-inform">The West Room is a room. The East Room is a room. The Problem Room is a room.
The East Room is east of The West Room. The Problem Room is west of The East Room.
</code></pre>
<p>This will put <code>The East Room</code> to the east of <code>The West Room</code> (explicitly) and <code>The West Room</code> to the west of <code>The East Room</code> (implicitly). Then we add <code>The Problem Room</code> to the west of <code>The East Room</code>, and as this is an explicit relation it overrides the implicit one. If we had instead tried to put <code>The Problem Room</code> to the east of <code>The West Room</code>, this would fail (can't override explicit connections). This will be covered more in some later section.</p>
<pre><code class="language-haskell id=connections">
data ConnectionExplicitness = Explicit | Implicit 
  deriving stock (Eq, Show, Read, Enum, Ord, Generic)

data Connection = Connection 
  { _connectionExplicitness :: ConnectionExplicitness
  , _connectionRoom :: Entity
  } deriving stock (Eq, Show, Read, Ord, Generic)

-- | The connections from a one room to another, stored by direction ID.
newtype MapConnections wm = MapConnections
  { unMapConnections :: Map.Map (WMDirections wm) Connection 
  }

deriving newtype instance (Generic (Map (WMDirections wm) Connection)) =&gt; Generic (MapConnections wm)
deriving newtype instance (Ord (WMDirections wm)) =&gt; Ord (MapConnections wm)
deriving newtype instance (Read (WMDirections wm), Ord (WMDirections wm)) =&gt; Read (MapConnections wm)
deriving newtype instance (Show (WMDirections wm)) =&gt; Show (MapConnections wm)
deriving stock instance (Eq (WMDirections wm)) =&gt; Eq (MapConnections wm)
</code></pre>
<h2 id="roomdata"><a class="header" href="#roomdata">RoomData</a></h2>
<p>And now we put together a couple of spatial properties (connections and regions) with some useful properties: Some rooms are inherently lit and therefore don't need a light source, and we also track whether the player has visited it to provide short descriptions on a return.</p>
<pre><code class="language-haskell id=room-data">-- | Whether a room has an intrinsic light-ness. This isn't equivalent to whether a
-- room is currently dark - for instance, a cave may have light (if the player has a
-- lantern) but the cave will be Dark.
data Darkness = Lighted | Dark 
  deriving stock (Eq, Show, Read, Enum, Ord, Generic)

-- | Whether a room has been visited before or not.
data IsVisited = Visited | Unvisited 
  deriving stock (Eq, Show, Read, Enum, Ord, Generic)

newtype ContainingRegion = ContainingRegion
  { unRegion :: Maybe Entity
  } deriving stock (Eq, Show)
    deriving newtype (Read, Ord, Generic)

data RoomData wm = RoomData
  { _roomIsVisited :: IsVisited
  , _roomDarkness :: Darkness
  , _roomMapConnections :: MapConnections wm
  , _roomContainingRegion :: ContainingRegion
  , _roomEnclosing :: Enclosing
  } deriving stock (Generic)

deriving stock instance (Ord (WMDirections wm)) =&gt; Ord (RoomData wm)
deriving stock instance (Read (WMDirections wm), Ord (WMDirections wm)) =&gt; Read (RoomData wm)
deriving stock instance (Show (WMDirections wm)) =&gt; Show (RoomData wm)
deriving stock instance (Eq (WMDirections wm)) =&gt; Eq (RoomData wm)

blankRoomData :: RoomData wm
blankRoomData = RoomData Unvisited Lighted (MapConnections Map.empty) (ContainingRegion Nothing) blankEnclosing


makeLenses ''RoomData
makeLenses ''Connection
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-specifics"><a class="header" href="#object-specifics">Object Specifics</a></h1>
<p>Here we define the standard library of object specifics. It's not very exciting; mostly we just list all the properties we define and some lenses for our property querying code. </p>
<pre><code class="language-haskell file=src/Yaifl/Objects/Specifics.hs">{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Objects.Specifics
  ( -- * Specifics
  ObjectSpecifics(..)
  ) where

import Solitude
import Yaifl.Properties.Container
import Yaifl.Properties.Enclosing
import Yaifl.Properties.Openable
import Yaifl.Properties.Property

data ObjectSpecifics =
  NoSpecifics
  | EnclosingSpecifics Enclosing
  | ContainerSpecifics Container 
  | OpenableSpecifics Openable
  deriving stock (Eq, Show, Read)

makePrisms ''ObjectSpecifics

instance HasProperty ObjectSpecifics Enclosing where
  propertyL = _EnclosingSpecifics `thenATraverse` (_ContainerSpecifics % containerEnclosing)

instance HasProperty ObjectSpecifics Container where
  propertyL = castOptic _ContainerSpecifics

instance HasProperty ObjectSpecifics Enterable where
  propertyL = _ContainerSpecifics % containerEnterable

instance HasProperty ObjectSpecifics Openable where
  propertyL = _OpenableSpecifics `thenATraverse` (_ContainerSpecifics % containerOpenable)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-objects"><a class="header" href="#dynamic-objects">Dynamic Objects</a></h1>
<p>One of the coolest features of Inform is to have attributes and properties of objects be dynamic; for instance, <code>Slightly Wrong</code> shows a room with a dynamic description. Originally I had this only for descriptions but it made more sense to be applied to entire objects.</p>
<p>The only times that we actually care about the underlying representation of an object is when creating them (because we need to supply an update function) and when reifying <code>AbstractObject</code>s from a <code>State</code>-based implementation. This is a big refactor I'm happy to have made because it cleanly breaks apart implementation (cached objects) and semantics (objects at a point in time). It does have the slight issue that we need to be cautious: if we reify a dynamic object at some point in time, then we change some part of the world that may affect its update function, we will need to re-reify the object.</p>
<pre><code class="language-haskell file=src/Yaifl/Objects/Dynamic.hs">
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Objects.Dynamic 
  ( -- * Types
    TimestampedObject(..)
  , ObjectUpdate(..)
  , AbstractObject(..)
  , AbstractThing
  , AbstractRoom
  , AnyAbstractObject
  -- * Lenses
  , tsCachedObject
  , tsCacheStamp
  , tsUpdateFunc
  ) where

import Solitude ( Generic, Either, makeLenses, Eff )
import Yaifl.Common ( WorldModel, Timestamp, HasID(..) )
import Yaifl.Objects.Object ( Object )
import Yaifl.Objects.ObjectData ( RoomData, ThingData )

&lt;&lt;timestamped-object&gt;&gt;
&lt;&lt;abstract-object&gt;&gt;
</code></pre>
<h2 id="timestamped-objects"><a class="header" href="#timestamped-objects">Timestamped Objects</a></h2>
<pre><code class="language-haskell id=timestamped-object">data TimestampedObject wm d = TimestampedObject
  { _tsCachedObject :: !(Object wm d)
  , _tsCacheStamp :: !Timestamp
  , _tsUpdateFunc :: ObjectUpdate wm d
  } deriving stock (Generic)

instance HasID (TimestampedObject wm d) where
  getID (TimestampedObject o _ _) = getID o

-- | Function to update an object. It is read-only on the world; i.e. it can only modify itself
newtype ObjectUpdate (wm :: WorldModel) d = ObjectUpdate
  { runObjectUpdate :: forall es. Object wm d -&gt; Eff es (Object wm d)
  } 
</code></pre>
<h2 id="abstract-objects"><a class="header" href="#abstract-objects">Abstract Objects</a></h2>
<pre><code class="language-haskell id=abstract-object">data AbstractObject wm d
  = DynamicObject (TimestampedObject wm d)
  | StaticObject (Object wm d)

instance HasID (AbstractObject wm d) where
  getID (StaticObject o) = getID o
  getID (DynamicObject ts) = getID ts

type AbstractThing wm = AbstractObject wm ThingData
type AbstractRoom wm = AbstractObject wm (RoomData wm)
type AnyAbstractObject wm = AbstractObject wm (Either ThingData (RoomData wm))

makeLenses ''TimestampedObject
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-objects"><a class="header" href="#creating-objects">Creating Objects</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Objects/Create.hs">{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Objects.Create
  ( -- * Effect
  ObjectCreation(..)
  , generateEntity
  , addAbstractThing
  , addAbstractRoom
  , addThing
  , addRoom
  , addThing'
  , addRoom'
  , addBaseObjects
  ) where

import Cleff.State ( State, get, runState )
import Solitude
import Yaifl.Common
import Yaifl.Logger ( debug, Log )
import Yaifl.Objects.Dynamic
import Yaifl.Objects.Move ( move )
import Yaifl.Objects.Object ( ObjType(ObjType), Object(Object) )
import Yaifl.Objects.ObjectData
import Yaifl.Objects.Query ( ObjectQuery )
import Yaifl.Objects.Specifics ( ObjectSpecifics(NoSpecifics) )
import Yaifl.Properties.Enclosing ( Enclosing )
import Yaifl.Properties.Property ( WMHasProperty )

&lt;&lt;creation-effect&gt;&gt;
&lt;&lt;make-object&gt;&gt;
&lt;&lt;add-objects&gt;&gt;
&lt;&lt;base-objects&gt;&gt;
</code></pre>
<pre><code class="language-haskell id=creation-effect">data ObjectCreation wm :: Effect where
  GenerateEntity :: Bool -&gt; ObjectCreation wm m Entity 
  AddAbstractThing :: AbstractThing wm -&gt; ObjectCreation wm m ()
  AddAbstractRoom :: AbstractRoom wm -&gt; ObjectCreation wm m ()

makeEffect ''ObjectCreation

type AddObjects wm es = '[ObjectCreation wm, State (Metadata wm), Log, ObjectQuery wm] :&gt;&gt; es
</code></pre>
<pre><code class="language-haskell id=make-object">makeObject :: 
  ObjectCreation wm :&gt; es
  =&gt; State (Metadata wm) :&gt; es
  =&gt; Text -- ^ Name.
  -&gt; Text -- ^ Description.
  -&gt; ObjType
  -&gt; Bool
  -&gt; Either ObjectSpecifics (WMObjSpecifics wm) -- ^ Object details.
  -&gt; d
  -&gt; Maybe (ObjectUpdate wm d) -- ^ 'Nothing' for a static object, 'Just f' for a dynamic object.
  -&gt; Eff es (Entity, AbstractObject wm d)
makeObject n d ty isT specifics details upd = do
  e &lt;- generateEntity isT
  t &lt;- getGlobalTime
  let obj = Object n d e ty t specifics details
  return (e, maybe (StaticObject obj) (DynamicObject . TimestampedObject obj t) upd)

addObject :: 
  WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; (AbstractObject wm d -&gt; Eff es ())
  -&gt; Text
  -&gt; Text
  -&gt; ObjType
  -&gt; Bool
  -&gt; Either ObjectSpecifics (WMObjSpecifics wm)
  -&gt; d
  -&gt; Maybe (ObjectUpdate wm d)
  -&gt; Eff es Entity
addObject updWorld n d ty isT specifics details updateFunc = do
  (e, obj) &lt;- makeObject n d ty isT specifics details updateFunc
  debug $ bformat (&quot;Made a new &quot; %! stext %! &quot; called &quot; %! stext %! &quot; with ID &quot; %! int)
    (if isThing obj then &quot;thing&quot; else &quot;room&quot;) n e
  updWorld obj
  lastRoom &lt;- use previousRoom
  if
     isThing e 
  then
    previousRoom .= e
  else
    move e lastRoom &gt;&gt; pass -- move it if we're still 
  return e
</code></pre>
<p>-- | A version of 'addRoom' that uses a state monad to provide imperative-like
-- descriptions of the internals of the object. Compare
-- @
-- addThing n d o (Just $ (ThingData default default default .. mod1)) ...
-- @ with @
-- addThing' n d o (someLensField .= 5)
-- @</p>
<pre><code class="language-haskell id=add-objects">addThing ::
  WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; Text -- ^ Name.
  -&gt; Text -- ^ Description.
  -&gt; ObjType -- ^ Type.
  -&gt; Maybe (Either ObjectSpecifics (WMObjSpecifics wm))
  -&gt; Maybe ThingData -- ^ Optional details; if 'Nothing' then the default is used.
  -&gt; Maybe (ObjectUpdate wm ThingData) -- ^ Static/Dynamic.
  -&gt; Eff es Entity
addThing name desc objtype specifics details = addObject addAbstractThing name desc objtype
  True (fromMaybe (Left NoSpecifics) specifics) (fromMaybe blankThingData details)

addThing' :: 
  WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; Text -- ^ Name.
  -&gt; Text -- ^ Description.
  -&gt; Eff '[State ThingData] r -- ^ Build your own thing monad!
  -&gt; Eff es Entity
addThing' n d stateUpdate = addThing n d (ObjType &quot;thing&quot;)
    Nothing (Just $ snd $ runPure $ runState blankThingData stateUpdate) Nothing

addRoom :: 
  WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; Text -- ^ Name.
  -&gt; Text -- ^ Description.
  -&gt; ObjType -- ^ Type.
  -&gt; Maybe (Either ObjectSpecifics (WMObjSpecifics wm))
  -&gt; Maybe (RoomData wm) -- ^
  -&gt; Maybe (ObjectUpdate wm (RoomData wm))  -- ^
  -&gt; Eff es Entity
addRoom name desc objtype specifics details upd = do
  e &lt;- addObject addAbstractRoom name desc objtype False
        (fromMaybe (Left NoSpecifics) specifics) (fromMaybe blankRoomData details) upd
  md &lt;- get
  when (isVoid $ md ^. firstRoom) (firstRoom .= e)
  return e

isVoid :: Entity -&gt; Bool
isVoid = (defaultVoidID ==)

addRoom' :: 
 WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; Text
  -&gt; Text
  -&gt; Eff '[State (RoomData wm)] v
  -&gt; Eff es Entity
addRoom' n d rd = addRoom n d (ObjType &quot;room&quot;)
  Nothing (Just $ snd $ runPure $ runState blankRoomData rd) Nothing
</code></pre>
<pre><code class="language-haskell id=base-objects">addBaseObjects ::
  WMHasProperty wm Enclosing
  =&gt; AddObjects wm es
  =&gt; Eff es ()
addBaseObjects = do
  addRoom' &quot;The Void&quot; &quot;If you're seeing this, you did something wrong.&quot; pass
  addThing' &quot;player&quot; &quot;It's you, looking handsome as always&quot; (thingDescribed .= Undescribed)
  firstRoom .= defaultVoidID
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-objects"><a class="header" href="#moving-objects">Moving Objects</a></h1>
<p>This is the first piece of code where we interact with objects at a higher level than foundational, and therefore we aim to exhibit the three layer cake model. That is, we aim to make as much separation between the things in layer 2 (things that require our monadic context) and those in layer 3 (the pure functions that do the work). It results in slightly more verbose code for this case, but it does pave the way for better testing later on.</p>
<pre><code class="language-haskell file=src/Yaifl/Objects/Move.hs">module Yaifl.Objects.Move 
  ( move
  ) where
import Cleff.State ( State )
import qualified Data.EnumSet as ES
import Display ( displayText )
import Solitude

import Yaifl.Common ( HasID(..), tickGlobalTime, Metadata (..) )
import Yaifl.Logger ( debug, Log )
import Yaifl.Objects.Object ( objData, objName )
import Yaifl.Objects.ObjectData ( thingContainedBy )
import Yaifl.Objects.Query
import Yaifl.Properties.Enclosing ( enclosingContains, Enclosing )
import Yaifl.Properties.Property ( WMHasProperty )
import Yaifl.Properties.Query ( getEnclosing, getPropertyOrThrow, setEnclosing )

&lt;&lt;move-func&gt;&gt;
</code></pre>
<pre><code class="language-haskell id=move-func">move :: 
  State (Metadata wm) :&gt; es
  =&gt; Log :&gt; es
  =&gt; ObjectQuery wm :&gt; es
  =&gt; WMHasProperty wm Enclosing
  =&gt; ObjectLike wm o1
  =&gt; ObjectLike wm o2
  =&gt; o1
  -&gt; o2
  -&gt; Eff es Bool
move oObj oLoc = withoutMissingObjects moveBlock moveHandler 
  where
    moveBlock = do
      &lt;&lt;lookup-move&gt;&gt;
      &lt;&lt;move-thing&gt;&gt;

      &lt;&lt;update-move&gt;&gt;
      --at this point we know it's a success
      return $ True
    moveHandler = handleMissingObject 
      (bformat (&quot;Failed to move ObjectID &quot; %! int %! &quot; to ObjectID &quot; %! int ) (getID oObj) (getID oLoc)) $ return False
</code></pre>
<pre><code class="language-haskell id=lookup-move">o' &lt;- getThing oObj
loc &lt;- getPropertyOrThrow &quot;enclosing part of new location&quot; oLoc =&lt;&lt; getEnclosing oLoc
let c = o' ^. objData % thingContainedBy
oldLocEnc &lt;- getPropertyOrThrow &quot;enclosing part of old location&quot; c =&lt;&lt; getEnclosing c
debug $ bformat (&quot;Moving &quot; %! stext %! &quot; from &quot; %! stext %! &quot; to &quot; %! stext) (o' ^. objName) (displayText c) (displayText (getID oLoc))
</code></pre>
<pre><code class="language-haskell id=move-thing">let moveObjects newId t oldLoc newLocEncl = let (newLoc', t') = nowContains newId newLocEncl t in (t', oldLoc `noLongerContains` t, newLoc')
    noLongerContains cont obj = cont &amp; (enclosingContains %~ ES.delete (getID obj))
    nowContains contId cont obj = (cont &amp; (enclosingContains %~ ES.insert (getID obj)), obj &amp; (objData % thingContainedBy .~ contId))
    (movedObj, oldLocation, newLocation) = moveObjects (getID oLoc) o' oldLocEnc loc
</code></pre>
<pre><code class="language-haskell id=update-move">setThing movedObj
mapM (uncurry setEnclosing) [(c, oldLocation), (getID oLoc, newLocation)] 
tickGlobalTime True
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rooms-1"><a class="header" href="#rooms-1">Rooms</a></h1>
<p>Brief introduction goes here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="directions"><a class="header" href="#directions">Directions</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Directions.hs">module Yaifl.Directions
  ( WithStandardDirections(..)
  , HasOpposite(..)
  , Direction(..)
  , WithDirections
  , WMStdDirections
  ) where

import Solitude hiding ( Down )
import Yaifl.Common

&lt;&lt;direction-injection&gt;&gt;
&lt;&lt;stock-directions&gt;&gt;
</code></pre>
<pre><code class="language-haskell id=direction-injection">class WithStandardDirections d where
  injectDirection :: Direction -&gt; d

class HasOpposite d where
  opposite :: d -&gt; d

type WithDirections (wm :: WorldModel) = (Ord (WMDirections wm), HasOpposite (WMDirections wm))
type WMStdDirections (wm :: WorldModel) = (WithStandardDirections (WMDirections wm), WithDirections wm)
</code></pre>
<pre><code class="language-haskell id=stock-directions">data Direction = 
  North
  | South
  | East
  | West
  | NorthWest
  | NorthEast
  | SouthWest
  | SouthEast
  | In
  | Out
  | Up
  | Down
  deriving stock (Eq, Show, Read, Ord, Enum, Generic, Bounded)

instance WithStandardDirections Direction where
  injectDirection = id

instance HasOpposite Direction where
  opposite = \case
    North -&gt; South
    South -&gt; North
    West -&gt; East
    East -&gt; West
    NorthWest -&gt; SouthEast
    NorthEast -&gt; SouthWest
    SouthEast -&gt; NorthWest
    SouthWest -&gt; NorthEast
    In -&gt; Out
    Out -&gt; In
    Up -&gt; Down
    Down -&gt; Up
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-connections"><a class="header" href="#making-connections">Making Connections</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Objects/Room.hs">{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Objects.Room
  --( isWestOf
  --, getMapConnection
where
 -- ) where

import Cleff.State ( State )
import qualified Data.Map as Map
import qualified Data.Text.Lazy.Builder as TLB
import Display ( displayText )
import Solitude

import Yaifl.Common ( Entity, HasID(getID), Metadata, WMDirections, whenConstructingM )
import Yaifl.Directions ( HasOpposite(opposite), WithDirections )
import Yaifl.Logger ( warn, Log )
import Yaifl.Objects.Object ( objData, Room )
import Yaifl.Objects.ObjectData ( MapConnections(MapConnections), Connection(..), ConnectionExplicitness(..), roomMapConnections )
import Yaifl.Objects.Query

hasSpecificConnectionTo ::
  ObjectQuery wm :&gt; es
  =&gt; State (Metadata wm) :&gt; es
  =&gt; ObjectLike wm o
  =&gt; WithDirections wm
  =&gt; Maybe ConnectionExplicitness 
  -&gt; o
  -&gt; WMDirections wm
  -&gt; Eff es (Maybe Entity)
hasSpecificConnectionTo mbExpl o dir = do
  r &lt;- getRoomMaybe o
  let v = getConnectionInDirection dir =&lt;&lt; r
  case v of
    Just (Connection ex' e) 
      | (maybe True (ex' ==) mbExpl) -&gt; return $ Just e
    _ -&gt; return Nothing

getMapConnection ::
  NoMissingObjects wm es
  =&gt; WithDirections wm
  =&gt; ObjectLike wm o
  =&gt; WMDirections wm
  -&gt; o
  -&gt; Eff es (Maybe Entity)
getMapConnection dir o = ((_connectionRoom &lt;$&gt;) . getConnectionInDirection dir) &lt;$&gt; getRoom o

getConnectionInDirection :: 
  WithDirections wm 
  =&gt; WMDirections wm 
  -&gt; Room wm 
  -&gt; Maybe Connection
getConnectionInDirection dir = preview (connectionLens dir % _Just)

connectionLens ::
  forall wm.
  WithDirections wm 
  =&gt; WMDirections wm 
  -&gt; Lens' (Room wm) (Maybe Connection)
connectionLens dir = objData % roomMapConnections % coercedTo @(Map.Map (WMDirections wm) Connection ) % at dir

makeConnection :: 
  WithDirections wm
  =&gt; ConnectionExplicitness
  -&gt; WMDirections wm 
  -&gt; Room wm 
  -&gt; (Room wm -&gt; Room wm)
makeConnection expl dir r = connectionLens dir ?~ Connection expl (getID r)

addDirectionFrom ::
  (ObjectLike wm o1, ObjectLike wm o2)
  =&gt; ObjectQuery wm :&gt; es
  =&gt; State (Metadata wm) :&gt; es
  =&gt; Log :&gt; es
  =&gt; WithDirections wm
  =&gt; WMDirections wm
  -&gt; o1
  -&gt; o2
  -&gt; Eff es Entity
addDirectionFrom = isDirectionFromInternal True

addDirectionFromOneWay ::
  (ObjectLike wm o1, ObjectLike wm o2)
  =&gt; '[ObjectQuery wm, State (Metadata wm), Log] :&gt;&gt; es
  =&gt; WithDirections wm
  =&gt; WMDirections wm
  -&gt; o1
  -&gt; o2
  -&gt; Eff es Entity
addDirectionFromOneWay = isDirectionFromInternal False 

isDirectionFromInternal ::
  (ObjectLike wm o1, ObjectLike wm o2)
  =&gt; '[ObjectQuery wm, State (Metadata wm), Log] :&gt;&gt; es
  =&gt; WithDirections wm
  =&gt; Bool
  -&gt; WMDirections wm
  -&gt; o1
  -&gt; o2
  -&gt; Eff es Entity
isDirectionFromInternal mkRev dir o1 o2 = withoutMissingObjects (do
    let opp = opposite dir
    -- ensure we have two rooms
    r2 &lt;- getRoom o2
    r1 &lt;- getRoom o1
    -- we log a warning if we're in construction and we are overriding an explicit connection
    -- apparently inform just doesn't let you do this, so...
    -- r1 is explicitly dir of r2; it is r2 we need to check
    -- r2 is implicitly (opposite dir) of r1.
    -- e.g. if r1 `isWestOf` r2, then r2 has an explicit west connection and r1 has an implicit east connection.
    whenConstructingM (isJust &lt;$&gt; hasSpecificConnectionTo (Just Explicit) r2 dir)
      -- TODO: this should be a nonblocking failure
      (warn $ TLB.fromText $ &quot;Overriding an explicitly set map direction of room &quot; &lt;&gt; displayText r1) 
    modifyRoom r2 (makeConnection Explicit dir r1)
    --only make the reverse if we want to
    when mkRev $ do
      -- something weird is happening if we're overriding an implicit direction with another implicit direction
      -- but I think in general we don't bother setting an implicit one
      whenConstructingM (isJust &lt;$&gt; hasSpecificConnectionTo (Just Implicit) r2 opp)
        (warn $ TLB.fromText $ &quot;Not using an implicit direction to overwrite an implicitly set map direction of room &quot; &lt;&gt; displayText r1) 
      -- and don't bother if there's any connection at all
      unless (isJust $ r1 ^? connectionLens opp) $ modifyRoom r1 (makeConnection Implicit dir r2)
    return (getID o1)) (handleMissingObject &quot;failed to make direction&quot; (return $ getID o1))

-- makeDirections True [&quot;West&quot;]

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<p>properties</p>
<pre><code class="language-haskell file=src/Yaifl/Properties/Property.hs">{-# LANGUAGE DefaultSignatures #-}

module Yaifl.Properties.Property 
  ( HasProperty(..)
  , WMHasProperty
  ) where

import Solitude ( Either(..), const, atraversal, eitherJoin, AffineTraversal' )
import Yaifl.Common ( WMObjSpecifics )

-- | A helper to define that a world model `wm` has a Property.
type WMHasProperty wm v = HasProperty (WMObjSpecifics wm) v

class HasProperty o v where
  default propertyL :: AffineTraversal' o v
  propertyL = atraversal Left const
  propertyL :: AffineTraversal' o v

instance (HasProperty a v, HasProperty b v) =&gt; HasProperty (Either a b) v where
  propertyL = propertyL `eitherJoin` propertyL

instance HasProperty () a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-set-modify"><a class="header" href="#get-set-modify">Get, Set, Modify</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Properties/TH.hs">{-# LANGUAGE DataKinds #-}

module Yaifl.Properties.TH
(
    makeSpecificsWithout
  , makePropertyFunction
  , SpecificsFunctions(..)
  , makeDirections
) where

import Solitude
import Language.Haskell.Meta hiding (myDefaultParseMode)nice 
import Data.Text (replace)
import Language.Haskell.Exts.Parser
import Language.Haskell.Exts.Extension
import Language.Haskell.TH (Name, Q, Dec, nameBase)

data SpecificsFunctions =
  GetX
  | SetX
  | ModifyX
  deriving stock (Show, Eq, Enum, Ord, Generic, Bounded)


myDefaultParseMode :: ParseMode
myDefaultParseMode = defaultParseMode
  { parseFilename = []
  , baseLanguage = Haskell2010
  , extensions = map EnableExtension [DataKinds, ExplicitForAll, ScopedTypeVariables ]
  }

makeSpecificsWithout :: [SpecificsFunctions] -&gt; Name -&gt; Q [Dec]
makeSpecificsWithout l prop = do
  v &lt;- mapM (makePropertyFunction prop) (universeSans l)
  return $ join v

makePropertyFunction :: Name -&gt; SpecificsFunctions -&gt; Q [Dec]
makePropertyFunction n sf = do
  return $ (case sf of
    GetX -&gt; replaceTH 
      &quot;getXSUBHERE :: MonadReader (World wm) m =&gt; Logger m =&gt; NoMissingObjects m =&gt; WMHasProperty wm XSUBHERE =&gt; MonadState (World wm) m =&gt; ObjectLike wm o =&gt; o -&gt; m (Maybe XSUBHERE)\ngetXSUBHERE = defaultPropertyGetter&quot;
    SetX -&gt; replaceTH 
      &quot;setXSUBHERE :: MonadReader (World wm) m =&gt; Logger m =&gt; WMHasProperty wm XSUBHERE =&gt; MonadState (World wm) m =&gt; HasID o =&gt; o-&gt; XSUBHERE-&gt; m ()\nsetXSUBHERE = defaultPropertySetter&quot;
    ModifyX -&gt; replaceTH 
      &quot;modifyXSUBHERE :: MonadReader (World wm) m =&gt; Logger m =&gt; NoMissingObjects m =&gt; WMHasProperty wm XSUBHERE =&gt; MonadState (World wm) m =&gt; ObjectLike wm o =&gt; o -&gt; (XSUBHERE -&gt; XSUBHERE) -&gt; m ()\nmodifyXSUBHERE = modifyProperty getXSUBHERE setXSUBHERE&quot;
    ) (toText $ nameBase n)

replaceTH :: Text -&gt; Text -&gt; [Dec]
replaceTH y x = either (\x' -&gt; [error $ toText x']) id (parseDecsWithMode myDefaultParseMode $ toString $ replace &quot;XSUBHERE&quot; x y)

makeDirections :: Bool -&gt; [Text] -&gt; Q [Dec]
makeDirections std dirs = do
  v &lt;- mapM (\n -&gt; do
    let replaceTH' y x = if std then replaceTH (replace &quot;XSUBHERE2&quot; &quot;(injectDirection XSUBHERE)&quot; y) x else replaceTH (replace &quot;XSUBHERE2&quot; &quot;XSUBHERE&quot; y) x
        r1 = replaceTH' &quot;isXSUBHEREOf :: MonadWorld wm m =&gt; WMStdDirections wm =&gt; m Entity -&gt; Entity -&gt; m Entity\nisXSUBHEREOf = isDirectionFrom XSUBHERE2&quot; n
        r2 = replaceTH' &quot;isXSUBHEREOfOneWay :: MonadWorld wm m =&gt; WMStdDirections wm =&gt; m Entity -&gt; Entity -&gt; m Entity\nisXSUBHEREOfOneWay = isDirectionFromOneWay XSUBHERE2&quot; n
    return $ r1 &lt;&gt; r2
    ) dirs
  return $ join v
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-properties"><a class="header" href="#standard-properties">Standard Properties</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enclosing"><a class="header" href="#enclosing">Enclosing</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Properties/Enclosing.hs">{-# LANGUAGE StrictData #-}
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Properties.Enclosing 
  ( -- * Types
    Enclosing(..)
  , blankEnclosing
  
    -- * Lenses
  , enclosingContains
  , enclosingCapacity
  ) where

import Solitude hiding (empty)
import Data.EnumSet (EnumSet, empty)
import Yaifl.Common (Entity)

-- | A component that contains other objects.
data Enclosing = Enclosing
  { _enclosingContains :: EnumSet Entity
  , _enclosingCapacity :: Maybe Int
  } deriving stock (Eq, Show, Read, Ord, Generic)

blankEnclosing :: Enclosing
blankEnclosing = Enclosing empty Nothing

makeLenses ''Enclosing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openable"><a class="header" href="#openable">Openable</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Properties/Openable.hs">module Yaifl.Properties.Openable 
  ( -- * Types
    Openable(..)
  ) where

import Solitude ( Eq, Ord, Read, Show, Generic )

-- | Whether the thing is open or not.
data Openable = Open | Closed 
  deriving stock (Eq, Show, Read, Ord, Generic)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container"><a class="header" href="#container">Container</a></h1>
<pre><code class="language-haskell file=src/Yaifl/Properties/Container.hs">
{-# LANGUAGE StrictData #-}
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Properties.Container 
  ( -- * Types
    Opacity(..)
  , Enterable(..)
  , Container(..)

  , isOpaqueClosedContainer
    -- * Lenses
  , containerOpacity
  , containerEnclosing
  , containerOpenable
  , containerEnterable
  ) where

import Solitude
import Yaifl.Properties.Enclosing ( Enclosing )
import Yaifl.Properties.Openable ( Openable(..) )

-- | If the container is see-through.
data Opacity = Opaque | Transparent 
  deriving stock (Eq, Show, Read, Ord, Generic)

-- | If the container is enterable (by a person or animal or other sentient being).
data Enterable = Enterable | NotEnterable
  deriving stock (Eq, Show, Read, Ord, Generic)

-- | A container.
data Container = Container
  { _containerOpacity :: Opacity
  , _containerEnclosing :: Enclosing
  , _containerOpenable :: Openable
  , _containerEnterable :: Enterable
  } deriving stock (Eq, Show, Read, Ord, Generic)

makeLenses ''Container

isOpaqueClosedContainer :: 
  Container
  -&gt; Bool
isOpaqueClosedContainer c = (_containerOpacity c == Opaque) &amp;&amp; (_containerOpenable c == Closed)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rulebooks-actions-and-activities"><a class="header" href="#rulebooks-actions-and-activities">Rulebooks, Actions, and Activities</a></h1>
<p>oh my</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-rulebook"><a class="header" href="#running-a-rulebook">Running a Rulebook</a></h1>
<p>go</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="action-processing"><a class="header" href="#action-processing">Action Processing</a></h1>
<p>a very special kind of running a rulebook</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="activities"><a class="header" href="#activities">Activities</a></h1>
<p>probably need to check inform for this</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="construction-and-execution"><a class="header" href="#construction-and-execution">Construction and Execution</a></h1>
<p>build it and run it</p>
<pre><code class="language-haskell file=src/Yaifl.hs">
module Yaifl
  (
    --module Yaifl.Common
 -- , module Yaifl.Messages
--  , module Yaifl.Rulebooks
 -- , module Yaifl.Properties
  --, module Yaifl.Activities
    newWorld
  , blankWorld
  , HasStandardProperties
  , PlainWorldModel
  , Game
  , runGame
  ) where
import Solitude

import Yaifl.World
import qualified Data.Map as DM
import Yaifl.Common
import Yaifl.Say
--import Yaifl.Rulebooks.ActionProcessing
import Yaifl.Properties.Property
import Yaifl.Properties.Openable
import Yaifl.Properties.Container
import Yaifl.Properties.Enclosing
import Yaifl.Directions
import Yaifl.Logger
import Cleff.State hiding ( zoom )
import Yaifl.Objects.Create
import Yaifl.Objects.Query
import Display
--import Yaifl.Objects.Create
--import Yaifl.Rulebooks.WhenPlayBegins
--import Yaifl.ActivityCollection
--import Yaifl.Directions

type PlainWorldModel = 'WorldModel () Direction () ()

type HasStandardProperties s = (
  WMHasProperty s Enclosing
  , WMHasProperty s Container
  , WMHasProperty s Enterable
  , WMHasProperty s Openable)

blankWorld :: World (s :: WorldModel)
blankWorld = World
  { _worldMetadata = blankMetadata
  , _worldStores = blankStores
  , _worldActions = blankActions
  , _messageBuffer = blankMessageBuffer
  }

blankActions :: WorldActions s
blankActions = WorldActions
  { _actions = () --DM.empty
  , _activities = ()--_wb
  , _whenPlayBegins = () --_wc
  , _actionProcessing = () --_wd
  }

blankStores :: WorldStores s
blankStores = WorldStores
  { _entityCounter = (Entity 1, Entity (-1))
  , _things = emptyStore
  , _rooms = emptyStore
  , _values = DM.empty
  , _concepts = ()
  }

blankMetadata :: Metadata s
blankMetadata = Metadata 
  { _title = &quot;Untitled&quot;
  , _roomDescriptions = SometimesAbbreviatedRoomDescriptions
  , _dirtyTime = False
  , _globalTime = 0
  , _darknessWitnessed = False
  , _currentPlayer = Entity 1
  , _currentStage = Construction
  , _previousRoom = defaultVoidID
  , _firstRoom = defaultVoidID
  }

type EffStack wm = '[Log, ObjectQuery wm, State (Metadata wm), ObjectCreation wm, IOE]
type EffStackNoIO wm = '[Log, ObjectQuery wm, State (Metadata wm), ObjectCreation wm]
type Game wm = Eff (EffStack wm) 

type UnderlyingEffStack wm = '[State (World wm), IOE] 

newWorld :: 
  WMHasProperty wm Enclosing
  =&gt; Eff (EffStack wm) ()
newWorld = do
  addBaseObjects
  pass
  {- addBaseActions &gt;&gt; -} 

convertToUnderlyingStack :: 
  forall wm. Eff (EffStack wm)
  ~&gt; Eff (UnderlyingEffStack wm) 
convertToUnderlyingStack = 
  runCreationAsLookup
  . (zoom worldMetadata) 
  . runQueryAsLookup
  . runAndIgnoreLogging
  . raiseUnderN @(State (World wm)) @(EffStackNoIO wm) @('[IOE])

runGame :: 
  Text 
  -&gt; Eff (EffStack wm) a
  -&gt; IO (World wm)
runGame t f = do
  (r, w) &lt;- runIOE $ runState blankWorld $ convertToUnderlyingStack f
  return w

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-world-state"><a class="header" href="#the-world-state">The World State</a></h1>
<p>This is the monolithic core of the library. It can be chunked into a few main pieces, each of which is handled by a separate effect handler to keep our separation of concerns as modular as possible (for instance, an object should not be able to run an <code>Action</code> when printing out some text!).</p>
<p>We put the message buffer as part of the state even though we are in <code>IO</code> because it allows us to directly consume the output (e.g. for testing).</p>
<pre><code class="language-haskell file=src/Yaifl/World.hs">
{-# LANGUAGE TemplateHaskell #-}
module Yaifl.World where
import Solitude
import Yaifl.Common

import Yaifl.Say
--import Yaifl.Rulebooks.Rulebook
--import Yaifl.Activities.Activity
--import Yaifl.Actions.Action
import Yaifl.Objects.Dynamic
import Yaifl.Objects.Query
import Cleff.State
import Yaifl.Objects.Object
import Yaifl.Objects.Create
import Display
--import Yaifl.Actions.Looking
--import Yaifl.Actions.Going

data World (wm :: WorldModel) = World
  { _worldMetadata :: Metadata wm
  , _worldStores :: WorldStores wm
  , _worldActions :: WorldActions wm
  , _messageBuffer :: MessageBuffer
  }

&lt;&lt;world-stores&gt;&gt;
&lt;&lt;world-actions&gt;&gt;

makeLenses ''World
makeLenses ''WorldModel
makeLenses ''WorldStores

&lt;&lt;world-other&gt;&gt;
</code></pre>
<hr />
<h2 id="metadata-1"><a class="header" href="#metadata-1">Metadata</a></h2>
<p>These fields are for information we need to keep around but don't have complex dependencies -- so we can define the metadata in <code>Yaifl.Common</code> and therefore break the import cycle of individual modules &lt;-&gt; <code>Yaifl.World</code> we have with a monolithic state record, but without having to write the boilerplate of an effect that exposes each of these fields individually.</p>
<pre><code class="language-haskell id=world-metadata">
data Metadata (wm :: WorldModel) = Metadata
  { _title :: Text
  , _roomDescriptions :: RoomDescriptions
  , _dirtyTime :: Bool
  , _globalTime :: Timestamp
  , _darknessWitnessed :: Bool
  , _currentPlayer :: Entity
  , _currentStage :: CurrentStage
  , _previousRoom :: Entity
  , _firstRoom :: Entity
  -- more to come I guess
  }

data CurrentStage = Construction | Verification | Runtime
  deriving stock (Eq, Show, Read, Ord, Enum, Generic)

makeLenses ''Metadata

getGlobalTime :: 
  State (Metadata wm) :&gt; es 
  =&gt; Eff es Timestamp
getGlobalTime = use globalTime

tickGlobalTime ::
  State (Metadata wm) :&gt; es 
  =&gt; Bool
  -&gt; Eff es ()
tickGlobalTime _ = pass

setTitle :: 
  State (Metadata wm) :&gt; es 
  =&gt; Text -- ^ New title.
  -&gt; Eff es ()
setTitle = (title .=)

whenConstructingM :: 
  State (Metadata wm) :&gt; es
  =&gt; Eff es Bool 
  -&gt; Eff es () 
  -&gt; Eff es ()
whenConstructingM cond = 
  whenM (andM [do
    cs &lt;- use currentStage
    return $ cs == Construction, cond])

</code></pre>
<pre><code class="language-haskell id=world-staging">data CurrentStage = Construction | Verification | Runtime
  deriving stock (Eq, Show, Read, Ord, Enum, Generic)

</code></pre>
<h3 id="room-descriptions"><a class="header" href="#room-descriptions">Room Descriptions</a></h3>
<p>Lifted directly from Inform; this sets whether to always print room descriptions (No..) even if the room is visited, to only print them on the first entry (Sometimes..), or never.</p>
<pre><code class="language-haskell id=room-descriptions">data RoomDescriptions = SometimesAbbreviatedRoomDescriptions
  | AbbreviatedRoomDescriptions
  | NoAbbreviatedRoomDescriptions 
  deriving stock (Eq, Show, Read, Ord, Enum, Generic)
</code></pre>
<h2 id="world-stores"><a class="header" href="#world-stores">World Stores</a></h2>
<p>The lookup tables for various objects, values, etc in the game. This is probably the most important part of the <code>World</code> state.</p>
<pre><code class="language-haskell id=world-stores">data WorldStores (wm :: WorldModel) = WorldStores
  { _entityCounter :: (Entity, Entity)
  , _things :: Store (AbstractThing wm)
  , _rooms :: Store (AbstractRoom wm)
  , _values :: Map Text (WMValues wm)
  , _concepts :: ()-- !(Store (AbstractConcept t r c))
  }
</code></pre>
<h2 id="world-actions"><a class="header" href="#world-actions">World Actions</a></h2>
<p>These are the dynamic parts that run things. This is the in-world actions, the standard activities (because user-defined activities can be done separately and don't need a lookup), and the two standalone rulebooks. Again, user-defined rulebooks act the same as activities and don't need to be stored around in the state.</p>
<pre><code class="language-haskell id=world-actions">
data WorldActions (wm :: WorldModel) = WorldActions
  { _actions :: () -- !(Map Text (Action wm))
  , _activities :: () -- !(ActivityCollection wm)
  , _whenPlayBegins :: () -- !(Rulebook wm () () Bool)
  , _actionProcessing :: ()-- ActionProcessing wm
  }

</code></pre>
<h3 id="timestamp-caching"><a class="header" href="#timestamp-caching">Timestamp Caching</a></h3>
<p>It is up to functions which might do some more complex processing (e.g. <code>move</code>) to update the time.</p>
<pre><code class="language-haskell id=timestamp">
newtype Timestamp = Timestamp
  { unTimestamp :: Int
  } deriving stock   (Show, Read, Generic)
    deriving newtype (Eq, Num, Enum, Ord, Real, Integral)

</code></pre>
<hr />
<h1 id="other"><a class="header" href="#other">Other</a></h1>
<pre><code class="language-haskell id=world-other">-- | Turn an `AbstractObject` into a regular `Object` and update the cache if needed.
reifyObject ::
  State (Metadata wm) :&gt; es
  =&gt; (AbstractObject wm d -&gt; Eff es ())
  -&gt; AbstractObject wm d
  -&gt; Eff es (Object wm d)
reifyObject _ (StaticObject v) = return v
reifyObject setFunc (DynamicObject ts) = do
  let co = _tsCachedObject ts
  now &lt;- getGlobalTime
  if
    _tsCacheStamp ts == now
  then
    return co
  else
    do
      -- update the object
      updatedObj &lt;- runObjectUpdate (_tsUpdateFunc ts) co
      t &lt;- getGlobalTime
      setFunc (DynamicObject $ TimestampedObject updatedObj t (_tsUpdateFunc ts))
      return updatedObj

reifyRoom :: 
  State (Metadata wm) :&gt; es
  =&gt; (ObjectCreation wm :&gt; es)
  =&gt; AbstractRoom wm
  -&gt; Eff es (Room wm)
reifyRoom = reifyObject addAbstractRoom

reifyThing :: 
  State (Metadata wm) :&gt; es
  =&gt; (ObjectCreation wm :&gt; es)
  =&gt; AbstractThing wm
  -&gt; Eff es (Thing wm)
reifyThing = reifyObject addAbstractThing

runCreationAsLookup :: 
  State (World wm) :&gt; es
  =&gt; Eff (ObjectCreation wm : es) 
  ~&gt; Eff es
runCreationAsLookup = interpret \case
  GenerateEntity bThing -&gt; if bThing then 
    ((worldStores % entityCounter % _1) &lt;&lt;%= (+1)) else ((worldStores % entityCounter % _2) &lt;&lt;%= (+1))
  AddAbstractRoom aRoom -&gt; worldStores % rooms % at (getID aRoom) ?= aRoom
  AddAbstractThing aThing -&gt; worldStores % things % at (getID aThing) ?= aThing

runQueryAsLookup :: 
  State (World wm) :&gt; es
  =&gt; (ObjectCreation wm :&gt; es)
  =&gt; (State (Metadata wm) :&gt; es)
  =&gt; Eff (ObjectQuery wm : es) 
  ~&gt; Eff es
runQueryAsLookup = interpret \case
  LookupThing e -&gt; do
    mbObj &lt;- use $ worldStores % things % at (getID e)
    case mbObj of
      Nothing -&gt; return 
        if isThing e 
          then 
            Left $ &quot;Tried to lookup a room as a thing &quot; &lt;&gt; displayText (getID e) 
          else 
            Left $ &quot;Could not find&quot; &lt;&gt; displayText (getID e)
      Just ao -&gt; withoutMissingObjects (Right &lt;$&gt; reifyThing ao) (\mo -&gt; return $ Left $ &quot;Failed to reify &quot; &lt;&gt; displayText mo)
  LookupRoom e -&gt; error &quot;&quot;
  SetRoom r -&gt; error &quot;&quot;
  SetThing t -&gt; error &quot;&quot;


{-


tickGlobalTime :: 
  MonadWorld wm m
  =&gt; Bool
  -&gt; m ()
--I have no idea what my plans were for this flag.
tickGlobalTime False = dirtyTime .= True
tickGlobalTime True = do
  dirtyTime .= False
  _ &lt;- globalTime &lt;%= (+1)
  pass
  -- debug (bformat (&quot;Dong. The time is now &quot; %! int %! &quot;.&quot;) r)

addBaseActions :: 
  HasLookingProperties wm
  =&gt; World wm
  -&gt; World wm
addBaseActions = foldr (.) id [
    addAction lookingActionImpl
  , addAction goingActionImpl
  ]


-}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-framework"><a class="header" href="#testing-framework">Testing Framework</a></h1>
<p>Sandwich is cool</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h1>
<p>yes</p>
<div style="break-before: page; page-break-before: always;"></div><p>There's some other files I haven't got anywhere to put.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-miscellania"><a class="header" href="#other-miscellania">Other Miscellania</a></h1>
<p>There's some additional baggage hanging around that, in the literate programming style, I needed to put somewhere. So here will do for now.</p>
<h2 id="common"><a class="header" href="#common">Common</a></h2>
<p>As this just includes some basic types, it doesn't really have a section specifically for it and as such does not have its file outline described anywhere. So it's here.</p>
<pre><code class="language-haskell file=src/Yaifl/Common.hs">{-# OPTIONS_GHC -Wno-orphans #-}
{-# LANGUAGE TemplateHaskell #-}

module Yaifl.Common
  (-- * Datatypes
  Entity(..)
  , Store(..)
  , HasID(..)
  , Timestamp(..)
  , WorldModel(..)
  , RoomDescriptions(..)

  -- * Metadata
  , Metadata(..)
  , CurrentStage(..)
  , getGlobalTime
  , tickGlobalTime
  , previousRoom
  , firstRoom
  , setTitle
  , whenConstructingM

  -- * Some defaults
  , defaultVoidID
  , defaultPlayerID
  , emptyStore

  -- * Object querying
  , isThing
  , isRoom

    -- * Type family nonsense
  , WMObjSpecifics
  , WMValues
  , WMDirections
  , WMShow
  , WMRead
  , WMOrd
  , WMEq
  )
where

import Cleff.State ( State )
import qualified Data.EnumMap.Strict as EM
import qualified Data.IntMap.Strict as IM
import Display ( Display(..) )

import Solitude

instance {-# OVERLAPPABLE #-} Display a where
  display = const &quot;No display instance&quot;

&lt;&lt;entity-def&gt;&gt;
&lt;&lt;thing-or-room&gt;&gt;
&lt;&lt;has-id&gt;&gt;
&lt;&lt;base-ids&gt;&gt;
&lt;&lt;store-def&gt;&gt;
&lt;&lt;alter-store&gt;&gt;
&lt;&lt;store-at&gt;&gt;
&lt;&lt;store-instances&gt;&gt;

&lt;&lt;room-descriptions&gt;&gt;
&lt;&lt;timestamp&gt;&gt;
&lt;&lt;world-model&gt;&gt;
&lt;&lt;world-model-families&gt;&gt;
&lt;&lt;world-model-constraints&gt;&gt;
&lt;&lt;world-metadata&gt;&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>There's some other files I haven't got anywhere to put.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
